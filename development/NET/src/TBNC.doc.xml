<?xml version="1.0" encoding="utf-8" ?>
<lib>	
	<namespace name="Softing.OPCToolbox.Client">
		<doc>
			<summary>
				<para>
					The <B>Softing.OPCToolbox.Client</B> namespace contains very generic, yet Softing 
					specific, common types (value types, interfaces, classes, etcetera).
				</para>
			</summary>
		</doc>
		<class name="ServerStatus">
				<doc>
					<unmanaged>
						<line>class TBC_EXPORT ServerStatus</line>
					</unmanaged>	
				</doc>			
			<constructor name="ServerStatus">
				<doc>
					<unmanaged>
						<line>public: ServerStatus</line>
					</unmanaged>
				</doc>
			</constructor>
			<field name="m_state">
					<doc>
            <unmanaged>
              <line>protected: unsigned long m_state;</line>
            </unmanaged>
					</doc>
			</field>
			<field name="m_startTime">
					<doc>
						<unmanaged>
							<line>protected: DateTime m_startTime;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_currentTime">
					<doc>
						<unmanaged>
							<line>protected: DateTime m_currentTime;</line>	
						</unmanaged>
					</doc>
			</field>
			<field name="m_vendorInfo">
					<doc>
						<unmanaged>
							<line>protected: tstring m_vendorInfo;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_productVersion">
					<doc>
						<unmanaged>
							<line>protected: tstring m_productVersion;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_supportedLcIds">
					<doc>
						<unmanaged>
							<line>protected: std::vector&#60;tstring&#62; m_supportedLcIds;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_lastUpdateTime">
					<doc>
						<unmanaged>
							<line>protected: DateTime m_lastUpdateTime;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_groupCount">
					<doc>
						<unmanaged>
							<line>protected: long m_groupCount;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_bandwidth">
					<doc>
						<unmanaged>
							<line>protected: long m_bandwidth;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_statusInfo">
					<doc>
						<unmanaged>
							<line>protected: tstring m_statusInfo;</line>
						</unmanaged>
					</doc>
			</field>
			<property name="VendorInfo">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getVendorInfo( );</line>
					</unmanaged>
					<value>
						A string that represents additional information about the server.
					</value>
				</doc>
			</property>
			<property name="State">
				<doc>
					<unmanaged>
						<line>public: unsigned long getState( );</line>
					</unmanaged>
					<value>
						The current status of the server.
					</value>
				</doc>
			</property>
			<property name="StartTime">
				<doc>
					<unmanaged>
						<line>public: DateTime getStartTime( );</line>
					</unmanaged>
					<value>
						A DateTime object that represents the time the server was started.
					</value>					
				</doc>
			</property>
			<property name="CurrentTime">
				<doc>
					<unmanaged>
						<line>public: DateTime getCurrentTime( );</line>						
					</unmanaged>					
					<value>
						A DateTime object that represents the time in the server of the method call.
					</value>					
				</doc>
			</property>
			<property name="ProductVersion">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getProductVersion( );</line>						
					</unmanaged>					
					<value>
						A string that represents the version of the server software.
					</value>					
				</doc>
			</property>			
			<property name="SupportedLcIds">
			<doc>
					<unmanaged>
						<line>public: std&#58;&#58;vector&#60;tstring&#62;&#38; getSupportedLcIds( );</line>						
					</unmanaged>					
					<value>
						An array of strings that represent all the culture names supported by the server.
						The culture name has the format "&#60;languagecode2&#62;&#45;&#60;country&#47;regioncode2&#62;".
					</value>					
				</doc>
			</property>			
			<property name="LastUpdateTime">
				<doc>
					<unmanaged>
						<line>public: DateTime getLastUpdateTime( );</line>						
					</unmanaged>					
					<value>
						A DateTime object that represents the time when the last data were sent to the client by callback.
					</value>					
				</doc>
			</property>
			<property name="GroupCount">
				<doc>
					<unmanaged>
						<line>public: long getGroupCount( );</line>						
					</unmanaged>					
					<value>
						The number of subscriptions created which clients have created in the server.
					</value>					
				</doc>
			</property>
			<property name="Bandwidth">
				<doc>
					<unmanaged>
						<line>public: long getBandwidth( );</line>						
					</unmanaged>					
					<value>
						The processor performance consumed by the server.
					</value>		
					<remarks>
						The value of 0xFFFFFFFF means that this value is unknown.
					</remarks>					
				</doc>
			</property>
			<property name="StatusInfo">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getStatusInfo( );</line>						
					</unmanaged>					
					<value>
						A string that represents a textual description of the current server state.
					</value>					
				</doc>
			</property>
		</class>
		<class name="ServerBrowser">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT ServerBrowser</line>
				</unmanaged>	
			</doc>
			<event name="BrowseServersCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleBrowseServersCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	tstring&#38; ipAddress,</line>
						<line>	std&#58;&#58;vector&#60;ServerBrowserData&#42;&#62;&#38; serverData,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</event>			
			<constructor name="ServerBrowser">
				<doc>					
					<unmanaged>						
						<line>public: ServerBrowser( </line>
						<line>	tstring ipAddress	 </line>
						<line>);</line>									
					</unmanaged>	
				</doc>
			</constructor>	
			<field name="m_ipAddress">
					<doc>
						<unmanaged>
							<line>protected: tstring m_ipAddress;</line>						
						</unmanaged>
					</doc>
			</field>
			<property name="IpAddress">	
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getIpAddress( );</line>
						<line>public: void setIpAddress(</line>
						<line>	tstring anIpAddress</line>
						<line>);</line>
					</unmanaged>
					<value>
						A string that represents the IP address of the computer on which the servers are to be browsed.
					</value>
				</doc>
			</property>			
			<method name="GetHashCode">
				<doc>
					<unmanaged>
						<line>public: unsigned long getUserData( );</line>
					</unmanaged>				
					<remarks>
						The object code is internally generated.
					</remarks>
				</doc>
			</method>		
			<method name="Browse">
				<doc>
					<unmanaged>
						<line>public: virtual long browse( </line>
						<line>	EnumOPCSpecification whatOPCspecification, </line>
						<line>	EnumServerBrowserData whatServerData, </line>
						<line>	std&#58;&#58;vector&#60;ServerBrowserData&#42;&#62;&#38; serverData, </line>
						<line>	ExecutionOptions* someExecutionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>
						<note>
							<line>When asynchronously executing  this method,  the execution context of the 
								<b>ExecutionOptions</b> object given as last parameter will identify the 
								server browser for which the asynchronous browse is made. So, before executing this 
								method the execution context must be set to the server browser's hash code.
							</line>
							<line>This is done using the statement below:</line>
							<code lang="C#">
&#47;&#47;We assume that a ServerBrowser object called "serverBrowser" is already created.
executionOptions.ExecutionContext = (uint)serverBrowser.GetHashCode(); 
							</code>	
							<code lang="Unmanaged C++">
&#47;&#47;We assume that a ServerBrowser object called "serverBrowser" is already created.
executionOptions.setExecutionContext(serverBrowser->getUserData());
							</code>
						</note>
						<para><b>Unmanaged C++</b></para><para>
							In the toolkit, memory is allocated for the <b>serverData</b> array and must be deallocated after finishing the browsing operation. In case the browsing is <b>synchronous</b> this must be undertaken by the person that uses the toolkit. In case the browsing is <b>asynchronous</b> this memory is deallocated in the toolkit and nobody has to care about deallocating it. The memory must be deallocated like in the statement below:
							<code lang="Unmanaged C++">
std::vector&#60;ServerBrowserData&#42;&#62;::iterator serverDataIterator;
for(serverDataIterator = serverData.begin(); serverDataIterator != serverData.end(); serverDataIterator++){
	delete (*serverDataIterator);
} //end for
							</code>
						</para>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
		</class>
		<class name="ServerBrowserData">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT ServerBrowserData</line>
				</unmanaged>	
			</doc>	
			<constructor name="ServerBrowserData">
				<doc>
					<unmanaged>
						<line>public: ServerBrowserData( );</line>
					</unmanaged>	
				</doc>
			</constructor>
			<field name="m_clsId">
					<doc>
						<unmanaged>
							<line>protected: tstring m_clsId;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_progId">
					<doc>
						<unmanaged>
							<line>protected: tstring m_progId;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_description">
					<doc>
						<unmanaged>
							<line>protected: tstring m_description;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_progIdVersionIndependent">
					<doc>
						<unmanaged>
							<line>protected: tstring m_progIdVersionIndependent;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_opcSpecification">
					<doc>
						<unmanaged>
							<line>protected: EnumOPCSpecification m_opcSpecification;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_url">
					<doc>
						<unmanaged>
							<line>protected: tstring m_url;</line>
						</unmanaged>
					</doc>
			</field>
			<property name="ClsId">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getClsId( );</line>
					</unmanaged>
					<value>
						A string that represents the server's CLSID.
					</value>
				</doc>
			</property>		
			<property name="Description">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getDescription( );</line>
					</unmanaged>
					<value>
						A string that represents the server's description.
					</value>
				</doc>
			</property>	
			<property name="OPCSpecification">
				<doc>
					<unmanaged>
						<line>public: EnumOPCSpecification getOpcSpecification( );</line>
					</unmanaged>
					<value>
						One of the <b>EnumOPCSpecification</b> values.
					</value>
				</doc>
			</property>	
			<property name="ProgId">
				<doc>
					<para>The ProgID contains a readable string that describes the component. The structure
					of the string is predefined:  &#91;Manufacturer.Server_name&#93;.
					</para>
					<unmanaged>
						<line>public: tstring&#38; getProgId( );</line>						
					</unmanaged>					
					<value>
						A string that represents the server's ProgID.
					</value>					
				</doc>
			</property>	
			<property name="ProgIdVersionIndependent">
				<doc>					
					<unmanaged>
						<line>public: tstring&#38; getProgIdVersionIndependent( );</line>						
					</unmanaged>					
					<value>
						A string that represents the server's version independent program ID.
					</value>					
				</doc>
			</property>	
			<property name="Url">
				<doc>					
					<unmanaged>
						<line>public: tstring&#38; getUrl( );</line>						
					</unmanaged>					
					<value>
						A string that represents the server's url.
					</value>					
				</doc>
			</property>	
		</class>
		<class name="ObjectSpaceElement">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT ObjectSpaceElement</line>
				</unmanaged>	
			</doc>	
			<constructor name="ObjectSpaceElement">
				<doc>
					<unmanaged>
						<line>public: ObjectSpaceElement( );</line>
					</unmanaged>
				</doc>
			</constructor>
			<event name="StateChangeCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleStateChangeCompleted(</line>
						<line>	EnumObjectState newState</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</event>
			<event name="PerformStateTransitionCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handlePerformStateTransitionCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</event>
			<event name="GetAttributesFromServerCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleGetAttributesFromServerCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	std&#58;&#58;vector&#60;EnumObjectAttribute&#62;&#38; whatAttributes,</line>
						<line>	std&#58;&#58;vector&#60;long&#62;&#38; results,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</event>
			<event name="SetAttributesToServerCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleSetAttributesToServerCompleted(</line>
						<line>	unsigned long executionContext,</line>		
						<line>	std&#58;&#58;vector&#60;EnumObjectAttribute&#62;&#38; whatAttributes,</line>
						<line>	std&#58;&#58;vector&#60;long&#62;&#38; results,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</event>
			<constant name="MaxAgeDevice">
				<doc>
					<unmanaged>
						<line>public: const unsigned long MAX_AGE_DEVICE = 0x00000000;</line>
					</unmanaged>
					<remarks>
						When reading data from a server, the values can be taken from the server’s internal cache or from the device.
						When using the <b>Read</b> method, the first parameter specifies the oldest (in milliseconds) acceptable cached 
						value when reading an item. If this parameter has the value of <b>MAX_AGE_DEVICE</b> constant then the values are 
						read directly from the device, i.e. from the data source. 
					</remarks>
				</doc>
			</constant>
			<constant name="MaxAgeCache">
				<doc>
					<unmanaged>
						<line>public: const unsigned long MAX_AGE_CACHE  = 0xFFFFFFFF;</line>
					</unmanaged>
					<remarks>
						When reading data from a server, the values can be taken from the server’s internal cache or from the device.
						When using the <b>Read</b> method, the first parameter specifies the oldest (in milliseconds) acceptable cached 
						value when reading an item. If this parameter has the value of <b>MAX_AGE_CACHE</b> constant then the values are always
						read from the server's cache. 
						<note>
							Cache reads are only possible if both the <b>DaSubscription</b> and <b>DaItem</b> objects are active since only in this case
							the cache is updated.
						</note>
					</remarks>
				</doc>
			</constant>
			<method name="GetHashCode">
				<doc>
					<unmanaged>
						<line>public: unsigned long getUserData( );</line>
					</unmanaged>
					<remarks>
						The object code is internally generated.
					</remarks>
				</doc>
			</method>	
			<property name="Valid">
				<doc>
					<unmanaged>
						<line>public: BOOL getValid( );</line>
					</unmanaged>
				</doc>
			</property>	
			<property name="CurrentState">
				<doc>
					<unmanaged>
						<line>public: EnumObjectState getCurrentState( );</line>
					</unmanaged>
				</doc>
			</property>	
			<property name="TargetState">
				<doc>
					<unmanaged>
						<line>public: EnumObjectState getTargetState( );</line>
						<line>public: void setTargetState(</line>
						<line>	EnumObjectState state</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</property>	
			<method name="PerformStateTransition">
				<doc>
					<unmanaged>
						<line>public: virtual long performStateTransition( </line>
						<line>	BOOL deep,</line>
						<line>	ExecutionOptions&#42; executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="Disconnect">
				<doc>
					<unmanaged>
						<line>public: virtual long disconnect( </line>
						<line>	ExecutionOptions&#42; executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>
						<note>
							<line>All the child objects are automatically disconnected.</line>
						</note>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>	
			<method name="GetAttributesFromServer">			
				<doc>
					<unmanaged>
						<line>public: virtual long getAttributesFromServer( </line>	
						<line>	std::vector&#60;EnumObjectAttribute&#62; whatAttributes, </line>
						<line>	std::vector&#60;long&#62; results, </line>
						<line>	ExecutionOptions&#42; executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>			
						<note>
							<line>The method is only used for <b>Session</b> and <b>Subscription</b> objects. Used with <b>Item</b> objects, the method
							returns E_INVALIDARG.</line>
							<line>If an <b>Item</b>'s attributes are to be updated, the method <b>GetDaItemAttributesFromServer</b> of the <b>DaSubscription</b> 
							object must be used.
							</line>
						</note>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>	
			<method name="Connect">
				<doc>
					<unmanaged>
						<line>public: virtual long connect( </line>
						<line>	BOOL deep,</line>
						<line>	BOOL active,</line>
						<line>	ExecutionOptions&#42; executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>			
						<note>
							<line>When a <b>DaSubscription</b> object is in the activated state the client receives by means of callbacks 
							the new values of the items that belong to the subscription.</line>
							<line>When an <b>AeSubscription</b> object is in the activated state the client receives by means of callbacks 
							the events that occur in the server’s eventarea.</line>
						</note>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>	
			<method name="SetAttributesToServer">
				<doc>
					<unmanaged>
						<line>public: virtual long setAttributesToServer( </line>	
						<line>	std::vector&#60;EnumObjectAttribute&#62; whatAttributes, </line>
						<line>	std::vector&#60;long&#62; results, </line>
						<line>	ExecutionOptions&#42; executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>			
						<note>
							<line>The method is only used for <b>Session</b> and <b>Subscription</b> objects. Used with <b>Item</b> objects, the method
							returns E_INVALIDARG.</line>
							<line>If an <b>Item</b>'s attributes are to be updated, the method <b>SetDaItemAttributesToServer</b> of the <b>DaSubscription</b> 
							object must be used.
							</line>
						</note>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>	
		</class>
		<enum name="EnumExecutionType">
			<doc>
				<unmanaged>
					<line>typedef enum tagEnumExecutionType&#123;</line>
					<line>&#125;EnumExecutionType;</line>
				</unmanaged>	
			</doc>
		</enum>
		<enum name="EnumObjectState">
			<doc>
				<unmanaged>
					<line>typedef enum tagEnumObjectState&#123;</line>
					<line>&#125;EnumObjectState;</line>
				</unmanaged>	
			</doc>
		</enum>
		<enum name="EnumObjectType">
			<doc>
				<unmanaged>
					<line>typedef enum tagEnumObjectType&#123;</line>
					<line>&#125;EnumObjectType;</line>
				</unmanaged>	
			</doc>
		</enum>
		<enum name="EnumObjectAttribute">
			<doc>
				<unmanaged>
					<line>typedef enum tagEnumObjectAttribute&#123;</line>
					<line>&#125;EnumObjectAttribute;</line>
				</unmanaged>	
			</doc>
		</enum>
		<enum name="EnumServerBrowserData">
			<doc>
				<unmanaged>
					<line>typedef enum tagEnumServerBrowserData&#123;</line>
					<line>&#125;EnumServerBrowserData;</line>
				</unmanaged>	
			</doc>
		</enum>
		<enum name="EnumAddressSpaceElementType">
			<doc>
				<unmanaged>
					<line>typedef enum tagEnumAddressSpaceElementType&#123;</line>
					<line>&#125;EnumAddressSpaceElementType;</line>
				</unmanaged>	
			</doc>
		</enum>
		<enum name="EnumPropertyData">
			<doc>
				<unmanaged>
					<line>typedef enum tagEnumPropertyData&#123;</line>
					<line>&#125;EnumPropertyData;</line>
				</unmanaged>	
			</doc>
		</enum>
		<enum name="EnumUpdateAttributesBehavior">
			<doc>
				<unmanaged>
					<line>typedef enum tagEnumUpdateAttributesBehavior&#123;</line>
					<line>&#125;EnumUpdateAttributesBehavior;</line>
				</unmanaged>	
			</doc>
		</enum>
		<enum name="EnumFilterBy">
			<doc>
				<unmanaged>
					<line>typedef enum tagEnumFilterBy&#123;</line>
					<line>&#125;EnumFilterBy;</line>
				</unmanaged>	
			</doc>
		</enum>
		<enum name="EnumClassContext">
			<doc>
				<unmanaged>
					<line>typedef enum tagEnumClassContext&#123;</line>
					<line>&#125;EnumClassContext;</line>
				</unmanaged>	
			</doc>
		</enum>
		<class name="ExecutionOptions">
			<doc>
				<unmanaged>
					<line>class ExecutionOptions</line>
				</unmanaged>	
			</doc>	
			<constructor name="ExecutionOptions">
				<doc>
					<unmanaged>
						<line>public: ExecutionOptions( );</line>
					</unmanaged>	
				</doc>
			</constructor>
			<constructor name="ExecutionOptions">
				<doc>
					<unmanaged>
						<line>public: ExecutionOptions(</line>
						<line>	EnumExecutionType executionType,</line> 
						<line>	unsigned long executionContext</line>
						<line>)</line>
					</unmanaged>	
				</doc>
			</constructor>
			<field name="m_executionType">
					<doc>
						<unmanaged>
							<line>protected: EnumExecutionType m_executionType;</line>						
						</unmanaged>
					</doc>
			</field>
			<field name="m_executionContext">
					<doc>
						<unmanaged>
							<line>protected: unsigned long m_executionContext;</line>						
						</unmanaged>
					</doc>
			</field>
			<property name="ExecutionType">
				<doc>
					<unmanaged>
						<line>public: EnumExecutionType getExecutionType( );</line>		
						<line>public: void setExecutionType(</line>
						<line>	EnumExecutionType aType</line>
						<line>);</line>
					</unmanaged>
					<value>
						One of the <b>EnumExecutionType</b> values.
					</value>
					<remarks>
						Implicitly, the execution type is synchronous.
					</remarks>
				</doc>
			</property>
			<property name="ExecutionContext">
				<doc>
					<unmanaged>
						<line>public: unsigned long getExecutionContext( );</line>		
						<line>public: void setExecutionContext(</line>
						<line>	unsigned long aContext</line>
						<line>);</line>
					</unmanaged>
					<value>
						An unique identifier for an asynchronous call.
					</value>
				</doc>
			</property>
		</class>
		<class name="Application">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT Application</line>					
				</unmanaged>	
				<remarks> This class cannot be inherited.</remarks>
			</doc>	
			<method name="Instance">
				<doc>
					<unmanaged>
						<line>public: TBC_EXPORT Application* API_CALL getApplication( );</line>	
						<line>public: static Application* Instance( );</line>	
					</unmanaged>				
					<remarks>
						<para>If an instance of the <b>Application</b> class already exists then this instance is returned.
						</para>								
						<para><b>Unmanaged C++</b></para><para>
						<line>The method <b>getApplication</b> should be used at the beginning, when no instance of <b>Application</b> class exists. After an instance has been created, both methods may be used to get this instance.</line>
						<line> To avoid memory leaks, after terminating the application the <b>releaseApplication</b> method must be called.</line>
						</para>
						<para>The following example shows how to use the application instance to initialize an application, add a <b>DaSession</b> object and terminate the application.
						</para>
						<code lang="Visual Basic">
...
//get the application instance
Dim application As Application &#61; Application&#46;Instance

&#47;&#47;initialize application
If ResultCode&#46;SUCCEEDED(application&#46;Initialize()) Then
					
	&#47;&#47;add a DaSession object to the application
	Dim session As New DaSession("opcda:///Softing.OPCToolboxDemo_ServerDA.1/{2E565242-B238-11D3-842D-0008C779D775}")
							
	...
	application.Terminate()
End If
&#46;&#46;&#46; 
						</code>	
						<code lang="Unmanaged C++">
...
//get the application instance
Application* application &#61; getApplication();

DaSession* session = NULL;

//initialize application
if(SUCCEEDED(application&#45;&#62;initialize()))&#123;
				
	//add a DaSession object to the application									
	session = new DaSession(_T("opcda:///Softing.OPCToolboxDemo_ServerDA.1/{2E565242-B238-11D3-842D-0008C779D775}"));
												
	...
	application->terminate();	
&#125;
...							
releaseApplication();
delete session;
						</code>	
						<code lang="C#">
...	
//get the application instance
Application application &#61; Application&#46;Instance;

//initialize application
if (ResultCode&#46;SUCCEEDED(application&#46;Initialize()))&#123;	
				
	&#47;&#47;add a DaSession object to the application					
	DaSession session &#61; new DaSession("opcda:///Softing.OPCToolboxDemo_ServerDA.1/{2E565242-B238-11D3-842D-0008C779D775}");
		
	...
	application.Terminate();
&#125;
...								
						</code>
					</remarks>
				</doc>
			</method>
			<method name="ReleaseApplication">
				<doc>
					<unmanaged>
						<line>public: static void Release();</line>	
						<line>public: TBC_EXPORT void API_CALL releaseApplication();</line>					
					</unmanaged>	
					<remarks>
						<para><b>Unmanaged C++</b></para><para>The following example shows how to use the application instance to initialize an application, add a <b>DaSession</b> object and terminate the application. It also shows how to release the application.
						</para>	
						<code lang="Unmanaged C++">
...
//get the application instance
Application* application &#61; getApplication();

DaSession* session = NULL;

//initialize application
if(SUCCEEDED(application&#45;&#62;initialize()))&#123;
					
	//add a DaSession object to the application						
	session = new DaSession(_T("opcda:///Softing.OPCToolboxDemo_ServerDA.1/{2E565242-B238-11D3-842D-0008C779D775}"));

	...
	//terminate application
	application->terminate();	
&#125;
...			
//release application
releaseApplication();

//delete the DaSession object cteated above
delete session;
						</code>
					</remarks>
				</doc>	
			</method>
		  	<property name="VersionOtb">
				<doc>
					<unmanaged>
						<line>public: unsigned short getVersionOtb(void);</line>
						<line>public: void setVersionOtb(unsigned short aValue);</line>
					</unmanaged>
					<remarks>
					Sets the version of the OPC toolkit internal DLL to be used. The current value is 441.
					This value is passed to the OPC toolkit internal dll and validated. If not valid, the 
					OPC server initialization will fail.
					</remarks>
				</doc>
			</property>
			<property name="ServiceName">
				<doc>
					<unmanaged>
						<line>public: tstring&amp; getServiceName(void);</line>
						<line>public: void setServiceName(tstring aValue);</line>
					</unmanaged>
					The name of NT service. This identifies the service
					<remarks>
					</remarks>
				</doc>
			</property>
			<property name="DaSessionList">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;DaSession*&#62; getDaSessionList()</line>
					</unmanaged>
					<value>
						An array with <b>DaSession</b> objects.
					</value>
				</doc>
			</property>	
			<property name="AeSessionList">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;AeSession*&#62; getAeSessionList()</line>						
					</unmanaged>					
					<value>
						An array with <b>DaSession</b> objects.
					</value>					
				</doc>
			</property>
			<property name="BadQualityValueString">
				<doc>
					<remarks>
						<para><b>C#, Visual Basic, C++</b></para><para>The property is used with a <b>Softing Control</b>. It will appear in a Windows Forms Control bound to a Softing Control. If the value of the item to which the Windows Forms Control is bound is not good, the message will be displayed in the Windows Forms Control instead of
the item's value.
						</para>
					</remarks>
					<value>
						A string that represents the message to be displayed in case the quality of a value is not good.
					</value>
				</doc>
			</property>	
			<property name="UpdateAttributesBehavior">
				<doc>
					<unmanaged>
						<line>public: EnumUpdateAttributesBehavior getUpdateAttributesBehavior( );</line>
						<line>public: void setUpdateAttributesBehavior(EnumUpdateAttributesBehavior aValue);</line>
					</unmanaged>
					<value>
						One of the <b>EnumUpdateAttributesBehavior</b> values.
					</value>
				</doc>
			</property>	
			<event name="TraceOutput">
				<doc>
					<unmanaged>
						<line>public: TraceEventHandler TraceOutput;</line>
					</unmanaged>
				</doc>
			</event>
			<method name="Activate">
				<doc>
					<unmanaged>
						<line>public: long activate(</line>
						<line>	EnumFeature feature,</line>
						<line>	tstring key</line>
						<line>);</line>
					</unmanaged>
					<remarks>
						If several Softing OPC features are activated via Binary licenses, the Activate method must be called for each active functionality with the appropriate license key.
						If one feature gets activated, the the rest of the features will be completely disabled. The Demo version - 90 minutes is also completely disabled for all not licensed
						features as soon as the first feature gets activated.
					</remarks>
				</doc>
			</method>
			<method name="ForceDemoVersion">
				<doc>
					<unmanaged>
					<line>public: long forceDemoVersion();</line>
					</unmanaged>
					<remarks>
					Forcing demo version is ireversible. All previously avtivated features are discarded and the cannot be reactivated.
					</remarks>
				</doc>
			</method>
			<method name="Initialize">
				<doc>
					<unmanaged>
						<line>public: long initialize( );</line>	
					</unmanaged>
					<remarks>
						The returned value should be checked with SUCCEEDED or with FAILED.		
					</remarks>
				</doc>
			</method>
			<method name="ProcessCommandLine">
				<doc>
					<unmanaged>
					<line>public: long processCommandLine(tstring&amp; aCommandLine);</line>
					</unmanaged>
					<remarks>					
					</remarks>
				</doc>
			</method>
			<method name="RemoveDaSession">
				<doc>
					<unmanaged>
						<line>public: long removeDaSession(</line>	
						<line>	DaSession* aDaSession</line>						
						<line>);</line>		
					</unmanaged>
					<remarks>
						<para>The returned value should be checked with SUCCEEDED or with FAILED.</para>
						<para><b>Unmanaged C++</b></para><para>Removing a <b>DaSession</b> object from application does not imply deallocating the memory
						it was allocated for it. Therefore, if a <b>DaSession</b> object was created using the <b>new</b> operator, the <b>delete</b> operator must be used to deallocate the memory for it.</para>
					</remarks>
				</doc>
			</method>
			<method name="RemoveAeSession">
				<doc>
					<unmanaged>
						<line>public: long removeAeSession(</line>
						<line>	AeSession* anAeSession</line>
						<line>);</line>
					</unmanaged>
					<remarks>
						<para>The returned value should be checked with SUCCEEDED or with FAILED.</para>
						<para><b>Unmanaged C++</b></para><para>Removing an <b>AeSession</b> object from application does not imply deallocating the memory
						it was allocated for it. Therefore, if an <b>AeSession</b> object was created using the <b>new</b> operator, the <b>delete</b> operator must be used to deallocate the memory for it.</para>
					</remarks>
				</doc>
			</method>
			<method name="Terminate">
				<doc>
					<unmanaged>
						<line>public: long terminate();</line>
					</unmanaged>
					<remarks>
						<para>The returned value should be checked with SUCCEEDED or with FAILED.</para>
					</remarks>
				</doc>
			</method>
			<method name="Trace">
				<doc>
					<unmanaged>
						<line>public: void trace(</line>
						<line>	EnumTraceLevel traceLevel,</line>
						<line>	EnumTraceGroup traceMask,</line>
						<line>	const TCHAR* objectID,</line>
						<line>	const TCHAR* message,</line>
						<line>	...);</line>
					</unmanaged>
					<remarks>
						The <b>objectId</b> and <b>message</b> parameters are strings without a fixed format. Any text can be written there.
					</remarks>
				</doc>
			</method>
			<method name="EnableTracing">
				<doc>
					<unmanaged>
						<line>public: void enableTracing(</line>		
						<line>	EnumTraceGroup errorLevelMask,</line>
						<line>	EnumTraceGroup warningLevelMask,</line>
						<line>	EnumTraceGroup infoLevelMask,</line>
						<line>	EnumTraceGroup debugLevelMask,</line>
						<line>	tstring fileName,</line>
						<line>	tstring secondFileName,</line>
						<line>	unsigned long fileMaxSize,</line>
						<line>	unsigned long maxBackups</line>
						<line>);</line>
					</unmanaged>					
				</doc>
			</method>
		</class>
		<class name="AddressSpaceElementBrowseOptions">
				<doc>
					<unmanaged>
						<line>class TBC_EXPORT AddressSpaceElementBrowseOptions</line>
					</unmanaged>	
				</doc>			
			<constructor name="AddressSpaceElementBrowseOptions">
				<doc>
					<unmanaged>
						<line>public: AddressSpaceElementBrowseOptions( );</line>
					</unmanaged>	
				</doc>
			</constructor>
			<field name="m_elementTypeFilter">
					<doc>
						<unmanaged>
							<line>protected: EnumAddressSpaceElementType m_elementTypeFilter;</line>
						</unmanaged>
						<remarks>
							<para><b>C#, Visual Basic, C++</b></para><para>The value of this attribute is EnumAddressSpaceElementType.ALL value.</para>
							<para><b>Unmanaged C++</b></para><para>The value of this attribute is EnumAddressSpaceElementType_ALL value.</para>
						</remarks>
					</doc>
			</field>
			<field name="m_elementNameFilter">
				<doc>
					<unmanaged>
						<line>protected: tstring m_elementNameFilter;</line>
					</unmanaged>
				</doc>
			</field>
			<field name="m_forceBrowseUp">
				<doc>
					<unmanaged>
						<line>protected: BOOL m_forceBrowseUp;</line>
					</unmanaged>
				</doc>
			</field>
			<property name="ElementNameFilter">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getElementNameFilter( );</line>		
						<line>public: void setElementNameFilter(</line>
						<line>	tstring aNameFilter</line>
						<line>);</line>
					</unmanaged>
					<value>
						A string that represents the name of the address space element.
					</value>					
				</doc>
			</property>
			<property name="ElementTypeFilter">
				<doc>
					<unmanaged>
						<line>public: EnumAddressSpaceElementType getElementTypeFilter( );</line>		
						<line>public: void setElementTypeFilter(</line>
						<line>	EnumAddressSpaceElementType</line>
						<line>);</line>
					</unmanaged>
					<value>
						One of the <b>EnumAddressSpaceElementType</b> values.
					</value>					
				</doc>
			</property>
			<property name="ForceBrowseUp">
				<doc>
					<unmanaged>
						<line>public: BOOL getForceBrowseUp( );</line>		
						<line>public: void setForceBrowseUp(</line>
						<line>	BOOL forceBrowseUp</line>
						<line>);</line>
					</unmanaged>
					<value>
						true if current browse needs to be forced.
					</value>
					<remarks>
						The default value for this field is <b>false</b>. 
					</remarks>
				</doc>
			</property>
			
		</class>
		<class name="DaAddressSpaceElementBrowseOptions">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT DaAddressSpaceElementBrowseOptions: public AddressSpaceElementBrowseOptions</line>
				</unmanaged>	
			</doc>			
			<constructor name="DaAddressSpaceElementBrowseOptions">
				<doc>
					<unmanaged>
						<line>public: DaAddressSpaceElementBrowseOptions( );</line>
					</unmanaged>	
				</doc>
			</constructor>
			<field name="m_maxElements">
					<doc>
						<unmanaged>
							<line>protected: unsigned long m_maxElements;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_returnProperties">
					<doc>
						<unmanaged>
							<line>protected: BOOL m_returnProperties;</line>						
						</unmanaged>						
					</doc>
			</field>
			<field name="m_returnPropertyValues">
					<doc>
						<unmanaged>
							<line>protected: BOOL m_returnPropertyValues;</line>						
						</unmanaged>						
					</doc>
			</field>
			<field name="m_retrieveItemID">
					<doc>
						<unmanaged>
							<line>protected: BOOL m_retrieveItemID;</line>						
						</unmanaged>						
					</doc>
			</field>
			<field name="m_vendorFilter">
					<doc>
						<unmanaged>
							<line>protected: tstring m_vendorFilter;</line>						
						</unmanaged>						
					</doc>
			</field>
			<field name="m_dataTypeFilter">
					<doc>
						<unmanaged>
							<line>protected: VARTYPE m_dataTypeFilter;</line>						
						</unmanaged>						
					</doc>
			</field>
			<field name="m_accessRightsFilter">
					<doc>
						<unmanaged>
							<line>protected: EnumAccessRights m_accessRightsFilter;</line>						
						</unmanaged>						
					</doc>
			</field>
			<property name="MaxElements">
				<doc>
					<unmanaged>
						<line>public: unsigned long getMaxElements( );</line>		
						<line>public: void setMaxElements(</line>
						<line>	unsigned long nElements</line>
						<line>);</line>
					</unmanaged>
					<value>
						The maximum number of elements to return.
					</value>					
				</doc>
			</property>
			<property name="VendorFilter">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getVendorFilter();</line>		
						<line>public: void setVendorFilter(</line>
						<line>	tstring aVendorFilter</line>
						<line>);</line>
					</unmanaged>
					<value>
						The name of the server manufacturer who defined the properties to be returned.
					</value>			
					<remarks>
						Only the properties defined by the this server manufacturer will be returned.
					</remarks>
				</doc>
			</property>
			<property name="AccessRightsFilter">
				<doc>
					<unmanaged>
						<line>public: EnumAccessRights getAccessRightsFilter( );</line>		
						<line>public: setAccessRightsFilter(</line>
						<line>	EnumAccessRights someAccessRights</line>
						<line>);</line>
					</unmanaged>
					<value>
						One of the <b>EnumAccessRights</b> values.
					</value>	
					<remarks>
						Only elements with these specific access rights will be returned.
					</remarks>
				</doc>
			</property>
			<property name="DataTypeFilter">
				<doc>
					<unmanaged>
						<line>public: VARTYPE getDataTypeFilter( );</line>		
						<line>public: void setDataTypeFilter(</line>
						<line>	VARTYPE aDataTypeFilter</line>
						<line>);</line>
					</unmanaged>
					<value>
						A data type for the values of the elements to be returned.
					</value>	
					<remarks>
						Only elements the values of which have specific data type will be returned.
					</remarks>
				</doc>
			</property>
			<property name="ReturnPropertyValues">
				<doc>
					<unmanaged>
						<line>public: BOOL getReturnPropertyValues( );</line>		
						<line>public: void setReturnPropertyValues(</line>
						<line>	BOOL returnPropertyValues</line>
						<line>);</line>
					</unmanaged>
					<value>
						A boolean which indicates whether property values should be returned with the properties.
					</value>
				</doc>
			</property>
			<property name="ReturnProperties">
				<doc>
					<unmanaged>
						<line>public: BOOL getReturnProperties( );</line>
						<line>public: void setReturnProperties(</line>
						<line>	BOOL returnProperties</line>
						<line>);</line>
					</unmanaged>
					<value>
						A boolean which indicates whether properties should be returned with each element.
					</value>
				</doc>
			</property>
			<property name="RetrieveItemId">
				<doc>
					<unmanaged>
						<line>public: BOOL getRetrieveItemId( );</line>		
						<line>public: void setRetrieveItemId(</line>
						<line>	BOOL retrieveItemId</line>
						<line>);</line>
					</unmanaged>
					<value>
						A boolean which indicates whether the item identifier must be retrieved.
					</value>
				</doc>
			</property>
		</class>
		<class name="AddressSpaceElement">
				<doc>
					<unmanaged>
						<line>class TBC_EXPORT AddressSpaceElement</line>
					</unmanaged>
				</doc>
			<constructor name="AddressSpaceElement">
				<doc>
					<unmanaged>
						<line>public: AddressSpaceElement(</line>
						<line>	EnumAddressSpaceElementType aType,</line>
						<line>	tstring aName,</line>
						<line>	tstring aQName,</line>
						<line>	unsigned long anObjectHandle);</line>
					</unmanaged>	
				</doc>
			</constructor>
			<field name="m_name">
					<doc>
						<unmanaged>
							<line>protected: tstring m_name;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_qName">
					<doc>
						<unmanaged>
							<line>protected: tstring m_qName;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_type">
					<doc>
						<unmanaged>
							<line>protected: EnumAddressSpaceElementType m_type;</line>
						</unmanaged>
					</doc>
			</field>
			<property name="Handle">
				<doc>
					<unmanaged>
						<line>public: unsigned long getHandle( );</line>
					</unmanaged>
					<value>
						A handle of an element in the server's address space.
					</value>	
					<remarks>
						The handle is unique for each AddressSpaceElement.
					</remarks>
				</doc>
			</property>
			<property name="Name">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getName( );</line>
						<line>public: void setName(</line>
						<line>	tstring aName</line>
						<line>);</line>
					</unmanaged>
					<value>
						A name for an element in the server's address space.
					</value>
					<remarks>
						The name of an AddressSpaceelement is not unique in the server address space.
					</remarks>
				</doc>
			</property>
			<property name="QualifiedName">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getQualifiedName( );</line>
						<line>public: void setQualifiedName(</line>
						<line>	tstring aQualifiedName</line>
						<line>);</line>
					</unmanaged>
					<value>
						A the full name for an element in the server's address space - path included
					</value>
					<remarks>
						The complete qualiddied name of an AddressSpaceelement is not unique in the server address space. The path is included.
					</remarks>
				</doc>
			</property>
			<property name="IsBranch">
				<doc>
					<unmanaged>
						<line>public: bool isBranch(void);</line>
					</unmanaged>
					<value>
						True if the element is a branch.
					</value>
					<remarks>
						
					</remarks>
				</doc>
			</property>
			<property name="IsLeaf">
				<doc>
					<unmanaged>
						<line>public: bool isLeaf(void);</line>
					</unmanaged>
					<value>
						True if the element is a leaf in the Address Space.
					</value>
					<remarks>
						
					</remarks>
				</doc>
			</property>
			<method name="Dispose">
				<doc>
					<unmanaged>
						<line>Not available!</line>
					</unmanaged>
				</doc>
			</method>
			<method name="Finalize">
				<doc>
					<unmanaged>
						<line>public: virtual ~AddressSpaceElement();</line>
					</unmanaged>
				</doc>
			</method>
		</class>
		<class name="DaSubscription">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT DaSubscription : virtual public ObjectSpaceElement</line>
				</unmanaged>	
			</doc>			
			<constructor name="DaSubscription">
				<doc>
					<unmanaged>
						<line>public: DaSubscription(</line>
						<line>	unsigned long updateRate,</line>
						<line>	DaSession* parentSession) </line>
					</unmanaged>
					<remarks>
						<para> The order of creating items that belong to a subscription does NOT coincide with the order the items are sent via a DataChanged event.</para>
						<para><b>Unmanaged C++</b></para><para>If a <b>DaSubscription</b> object was created using the <b>new</b> operator, the <b>delete</b> operator must be used to deallocate the memory for it. This operation must be done after the <b>terminate</b> method of the <b>Application</b> object was called.</para>
						<br></br>
						<para><b>Unmanaged C++</b></para><para>The following example shows how to create a new  <b>DaSubscription</b> object and ,at the end, deallocate the memory for it.</para>
						<code lang="Unmanaged C++">
...
using namespace SoftingOPCToolboxClient;
...
Application* application = getApplication();
	
if(SUCCEEDED(application->initialize())){
	
	//create a new DaSession object
	DaSession* session = new DaSession(_T("opcda:///Softing.OPCToolboxDemo_ServerDA.1/{2E565242-B238-11D3-842D-0008C779D775}"));
			
	DaSubscription* subscription = new DaSubscription(1000, session);

	...
	application->terminate();	
	releaseApplication();
		
	//deallocates the memory allocated for the Dasession object
	delete session;
	//dealocates the memory allocated for the DaSubscription object
	delete subscription;
}
						</code>		
					</remarks>
				</doc>
			</constructor>	
			<event name="DataChanged">
				<doc>
					<unmanaged>
						<line>virtual void handleDataChanged(</line>
						<line>	const std::vector&#60;DaItem*&#62;&#38; items,</line>
						<line>	const std::vector&#60;ValueQT*&#62;&#38; values,</line>
						<line>	const std::vector&#60;long&#62;&#38; results</line>
						<line>);</line>
					</unmanaged>
					<remarks>
					<para>For the client to be notified about the value changes, the subscription and the items belonging to it must be in active state.</para>
					<para> The order of the elements in the <i>items</i> array does NOT coincide with the order the items were created for the subscription.</para>
					</remarks>
				</doc>
			</event>

			<event name="DataChangedEx">
				<doc>
					<unmanaged>
						<line>virtual void handleDataChangedEx(</line>
						<line>	unsigned long executionContext,</line>
						<line>	const std::vector&#60;DaItem*&#62;&#38; items,</line>
						<line>	const std::vector&#60;ValueQT*&#62;&#38; values,</line>
						<line>	const std::vector&#60;long&#62;&#38; results</line>
						<line>);</line>
					</unmanaged>	
					<remarks>
					<para>For the client to be notified about the value changes, the subscription and the items belonging to it must be in active state.</para>
					<para> The order of the elements in the <i>items</i> array does NOT coincide with the order the items were created for the subscription.</para>
					</remarks>
				</doc>
			</event>

			<event name="ValidateDaItemsCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleValidateDaItemsCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	std::vector&#60;DaItem*&#62;&#38; items,</line>
						<line>	std::vector&#60;long&#62;&#38; results</line>						
						<line>);</line>
					</unmanaged>						
				</doc>
			</event>	
			<event name="GetDaItemAttributesFromServerCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleGetDaItemAttributesFromServerCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	std::vector&#60;DaItem*&#62;&#38; items,</line>
						<line>	std::vector&#60;EnumObjectAttribute&#62;&#38; whatAttributes,</line>
						<line>	std::vector&#60;long&#62;&#38; results,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>						
				</doc>
			</event>
			<event name="SetDaItemAttributesToServerCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleSetDaItemAttributesToServerCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	std::vector&#60;DaItem*&#62;&#38; items,</line>
						<line>	std::vector&#60;EnumObjectAttribute&#62;&#38; whatAttributes,</line>
						<line>	std::vector&#60;long&#62;&#38; results,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>						
				</doc>
			</event>
			<event name="ReadCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleReadCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	const std::vector&#60;DaItem*&#62;&#38; items,</line>
						<line>	const std::vector&#60;ValueQT*&#62;&#38; values,</line>	
						<line>	const std::vector&#60;long&#62;&#38; results,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>						
				</doc>
			</event>
			<event name="WriteCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleWriteCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	const std::vector&#60;DaItem*&#62;&#38; items,</line>
						<line>	const std::vector&#60;ValueQT*&#62;&#38; values,</line>	
						<line>	const std::vector&#60;long&#62;&#38; results,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>						
				</doc>
			</event>
			<field name="m_itemList">
					<doc>
						<unmanaged>
							<line>protected: std::map&#60;unsigned long,DaItem*&#62; m_itemList;</line>						
						</unmanaged>
					</doc>
			</field>
			<field name="m_session">
					<doc>
						<unmanaged>
							<line>protected: DaSession* m_session;</line>						
						</unmanaged>
					</doc>
			</field>
			<property name="DaSession">
				<doc>
					<unmanaged>
						<line>public: DaSession* getDaSession();</line>	
						<line>void setDaSession(</line>	
						<line>	DaSession* aSession</line>
						<line>);</line>
					</unmanaged>					
					<value>
						The <b>DaSession</b> object to which the subscription belongs.
					</value>					
				</doc>
			</property>	
			<property name="ItemList">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;DaItem*&#62; getItemList( );</line>						
					</unmanaged>					
					<value>
						An array with <b>DaItem</b> objects that belong to the subscription.
					</value>					
				</doc>
			</property>	
			<property name="RequestedUpdateRate">
				<doc>
					<unmanaged>
						<line>public: unsigned long getRequestedUpdateRate( );</line>	
						<line>public: void setRequestedUpdateRate(</line>
						<line>unsigned long requestedUpdateRate</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An integer that represents the requested speed.
					</value>					
				</doc>
			</property>	
			<property name="RevisedUpdateRate">
				<doc>
					<unmanaged>
						<line>public: unsigned long getRevisedUpdateRate( );</line>						
					</unmanaged>					
					<value>
						An integer that represents the actual update rate.
					</value>					
				</doc>
			</property>	
			<property name="RequestedKeepAliveTime">
				<doc>
					<unmanaged>
						<line>public: unsigned long getRequestedKeepAliveTime( );</line>
						<line>public: void setRequestedKeepAliveTime(</line>
						<line>unsigned long requestedKeepAliveTime</line>
						<line>);</line>
					</unmanaged>					
					<value>
						 An integer that represents the requested keep alive time.
					</value>					
				</doc>
			</property>	
			<property name="RevisedKeepAliveTime">
				<doc>
					<unmanaged>
						<line>public: unsigned long getRevisedKeepAliveTime();</line>						
					</unmanaged>					
					<value>
						 An integer that represents the actual keep alive time.
					</value>					
				</doc>
			</property>	
			<property name="Name">
				<doc>
					<unmanaged>
						<line>public: tstring getName( );</line>	
						<line>public: void setName(</line>	
						<line>	tstring name</line>	
						<line>);</line>	
					</unmanaged>					
					<value>
						A string that represents the subscription name.
					</value>
					<remarks>
						Two subscriptions with the same name can't belong to the same session.
						<note>
							If the client does not set a name for the subscription, the server will generate a unique name for it.
						</note>
					</remarks>
				</doc>
			</property>	
			<property name="Deadband">
				<doc>
					<unmanaged>
						<line>public: float getDeadband( );</line>	
						<line>void setDeadband(</line>
						<line>	float deadband</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A float that represents the minimum percentage change required to trigger a data update for an item.
					</value>					
				</doc>
			</property>	
			<property name="TimeBias">
				<doc>
					<unmanaged>
						<line>public: long getTimeBias( );</line>	
						<line>public: void setTimeBias(</line>
						<line>long timeBias</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An integer that represents the deviation from GMT.
					</value>					
				</doc>
			</property>	
			<property name="LocaleId">
				<doc>
					<unmanaged>
						<line>public: tstring getLocaleId( );</line>
						<line>public: void setLocaleId(</line>
						<line>	tstring localeId</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents the language identifier.
					</value>					
				</doc>
			</property>	
			<method name="RemoveDaItem">
				<doc>
					<unmanaged>
						<line>public: long removeDaItem(</line>	
						<line>	DaItem* anItem</line>						
						<line>);</line>		
					</unmanaged>
					<remarks>
						<para>The returned value should be checked with SUCCEEDED or with FAILED.</para>
						<para><b>Unmanaged C++</b></para><para>Removing a <b>DaItem</b> object from subscription does not imply deallocating the memory
						it was allocated for it. Therefore, if a <b>DaItem</b> object was created using the <b>new</b> operator, the <b>delete</b> operator must be used to deallocate the memory for it.</para>						
					</remarks>
				</doc>
			</method>
			<method name="Read">
				<doc>
					<unmanaged>
						<line>public: virtual long read( </line>
						<line>	unsigned long maxAge,</line>
						<line>	std::vector&#60;DaItem*&#62; items,</line>
						<line>	std::vector&#60;ValueQT*&#62;&#38; values,</line>
						<line>	std::vector&#60;long&#62;&#38; results,</line>
						<line>	ExecutionOptions* executionOptions</line>						
						<line>); </line>	
					</unmanaged>
					<remarks>
						<para><b>C#, Visual Basic, C++</b></para><para>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.
						<br></br>
							If the server's cache contains a value newer than the specified maxAge, this value will be sent to the client.
							Otherwise the value will be taken directly from the data source(from device).	
						</para>
						<para><b>Unmanaged C++</b></para><para>
						In the toolkit, memory is allocated for the <b>values</b> array and must be deallocated after finishing the reading operation. In case the reading is <b>synchronous</b> this must be undertaken by the person that uses the toolkit. In case the reading is <b>asynchronous</b> this memory is deallocated in the toolkit and nobody has to care about deallocating it.</para>						
						<para> The following lines show how to synchronously read the values of some items using a DaSubscription object.</para>
						<code lang="Unmanaged C++">
...
using namespace SoftingOPCToolboxClient;
...
ExecutionOptions executionOptions;
unsigned long readCount = 3;
std::vector&#60;DaItem*&#62;itemsToRead(readCount,NULL);
std::vector&#60;DaItem*&#62;::iterator itemsToReadIterator;
std::vector&#60;ValueQT*&#62; valuesToRead(readCount,NULL);
std::vector&#60;ValueQT*&#62;::iterator valuesToReadIterator;
std::vector&#60;long&#62; readResults(readCount,E_FAIL);

Application* application = getApplication();
	
if(SUCCEEDED(application->initialize())){
	
	//create a new DaSession object
	DaSession* session = new DaSession(_T("opcda:///Softing.OPCToolboxDemo_ServerDA.1/{2E565242-B238-11D3-842D-0008C779D775}"));							
										
	DaSubscription* subscription = new DaSubscription(1000, session);
									
	DaItem* item1 = new DaItem(_T("maths.sin"), subscription);
	
	DaItem* item2 = new DaItem(_T("time.local.second"), subscription);
	
	DaItem* item3 = new DaItem(_T("increment.UI1"), subscription);
									
	itemsToRead[0] = item1;
	itemsToRead[1] = item2;
	itemsToRead[2] = item3;
	
	executionOptions.setExecutionType(EnumExecutionType_SYNCHRONOUS);
	session->connect(TRUE,FALSE,executionOptions);
	if (SUCCEEDED(result = subscription->read(
								0,
								itemsToRead,															
								valuesToRead,
								readResults,
								&#38;executionOptions))){

		_tprintf(_T(" \nRead items using subscription \n"));	
		...
		//do something with the read values
		...
		
		//dealocate the memory allocated for the <b>valuesToRead</b> array
		for(valuesToReadIterator = valuesToRead.begin(); valuesToReadIterator != valuesToRead.end(); valuesToReadIterator++){

			if( *valuesToReadIterator != NULL)
				delete *valuesToReadIterator;

		} //end for

	} //end if
	
	...
	//do some work here
	...
	application->terminate();	
	releaseApplication();
									
	delete session;
	delete subscription;
	delete item1;
	delete item2;
	delete item3;
}							
						</code>
						<code lang="C#">
...
using Softing.OPCToolbox.Client;							
...		
static void Main(string[] args){

	ValueQT[] values;
	int[] results ;
	ExecutionOptions executionOptions = new ExecutionOptions(); 
	Application application = Application.Instance;
	
	if (ResultCode.SUCCEEDED(application.Initialize())){	
	
		//create a new DaSession object
		DaSession session = new DaSession("opcda://localhost/Softing.OPCToolboxDemo_ServerDA/{2e565242-b238-11d3-842d-0008c779d775}");
																			
		DaSubscription subscription = new DaSubscription(500, session);									
	
		DaItem item1 = new DaItem("maths.sin", subscription);
		
		DaItem item2 = new DaItem("time.local.second", subscription);									

		DaItem item3 = new DaItem("increment.UI1 array", subscription);									
	
		itemList[0] = item1;
		itemList[1] = item2;
		itemList[2] = item3;
	
		session.Connect(true,false,executionOptions);									
		if (ResultCode.SUCCEEDED(subscription.Read(
								100,
								itemList,
								out values,															
								out results,
								executionOptions))){														

			Console.WriteLine(" Subscription synchronous read succeeded");	
			...
			//do something with the read values
			...															
		} 
		else{
			Console.WriteLine(" Synchronous subscription read failed!");
		}//end  else...if
		...
		//do some work here
		...
		application.Terminate();									
	}	
}							
						</code>
						<code lang="Visual Basic">
...
Imports Softing.OPCToolbox.Client						
...		
Shared Sub Main(ByVal args As String())

	Dim values As ValueQT()
	Dim results As Integer()
	Dim executionOptions As New ExecutionOptions
	
	Dim application As Application = Application.Instance
	
		If ResultCode.SUCCEEDED(application.Initialize())	
	
		//create a new DaSession object
		Dim session As New DaSession("opcda://localhost/Softing.OPCToolboxDemo_ServerDA/{2e565242-b238-11d3-842d-0008c779d775}")
																				
		Dim subscription As New DaSubscription(Convert.ToUInt32(500), session)
										
		Dim item1 As New DaItem("maths.sin", subscription)
		
		Dim item2 As New DaItem("time.local.second", subscription)

		Dim item3 As New DaItem("increment.UI1 array", subscription)
										
		itemList(0) = item1
		itemList(1) = item2
		itemList(2) = item3
	
		session.Connect(True, False, executionOptions)	

		Dim maxAge As System.UInt32 = Convert.ToUInt32(100)
		If ResultCode.SUCCEEDED(subscription.Read(
								maxAge, _
								itemList, _
								values, _															
								results, _
								executionOptions))														

			Console.WriteLine(" Subscription synchronous read succeeded")	
			...
			//do something with the read values
			...															
		Else									
			Console.WriteLine(" Synchronous subscription read failed!")
		End If //end  else...if
		...
		//do some work here
		...
		application.Terminate()								
	End If	
End Sub							
						</code>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="Write">
				<doc>
					<unmanaged>
						<line>public: virtual long write( </line>
						<line>	std::vector&#60;DaItem*&#62; items,</line>
						<line>	std::vector&#60;ValueQT*&#62; values,</line>
						<line>	std::vector&#60;long&#62;&#38; results,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>); </line>
					</unmanaged>
					<remarks>
					<para>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.
					</para>
						There may be servers that do not support writing the quality and timestamp.
						<para><b>Unmanaged C++</b></para><para>
						 In this case the quality of the ValueQT object should be set to <b>EnumQuality.QUALITY_NOT_SET</b> and its timestamp to the default value.
						e.g
<code lang="Unmanaged C++">
Variant data;
DateTime writeDateTime;
data.setBSTR(_T("Softing"));
ValueQT valueToWrite = new ValueQT(data, EnumQuality_QUALITY_NOT_SET, writeDateTime);
</code>
</para>
<para><b>C#, Visual Basic, C++</b></para><para>
 In this case the quality of the ValueQT object should be set to <b>EnumQuality.QUALITY_NOT_SET</b> and its timestamp to the default value.
e.g
<code lang="C#">
DateTime writeDateTime = new DateTime();
ValueQT valueToWrite = new ValueQT(11, EnumQuality.QUALITY_NOT_SET, writeDateTime);
</code>  
					</para>
					<para><b>Unmanaged C++</b></para><para>
						In the toolkit, memory is allocated for the <b>values</b> array and must be deallocated after finishing the writing operation. In case the writing is <b>synchronous</b> this must be undertaken by the person that uses the toolkit. In case the writing is <b>asynchronous</b> this memory is deallocated in the toolkit and nobody has to care about deallocating it.</para>											
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="ValidateDaItems">
				<doc>
					<unmanaged>
						<line>public: virtual long validateDaItems(</line>	
						<line>	std::vector&#60;DaItem*&#62; items,</line>	
						<line>	std::vector&#60;long&#62;&#38; results,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>
					</unmanaged>
					<remarks>
						<para>The returned value should be checked with SUCCEEDED or with FAILED.</para>	
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="GetDaItemAttributesFromServer">
				<doc>
					<unmanaged>
						<line>public:virtual long getDaItemAttributesFromServer(</line>	
						<line>	std::vector&#60;DaItem*&#62; items,</line>	
						<line>	std::vector&#60;EnumObjectAttribute&#62; whatAttributes,</line>
						<line>	std::vector&#60;long&#62;&#38; results,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>
					</unmanaged>
					<remarks>
						<para>The returned value should be checked with SUCCEEDED or with FAILED.</para>	
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="SetDaItemAttributesToServer">
				<doc>
					<unmanaged>
						<line>public:virtual long setDaItemAttributesToServer(</line>	
						<line>	std::vector&#60;DaItem*&#62; items,</line>	
						<line>	std::vector&#60;EnumObjectAttribute&#62; whatAttributes,</line>
						<line>	std::vector&#60;long&#62;&#38; results,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>		
					</unmanaged>
					<remarks>
						<para>The returned value should be checked with SUCCEEDED or with FAILED.</para>	
						<note>
							If the server's cache contains a value newer than the specified maxAge, this value will be sent to the client.
							Otherwise the value will be taken directly from the data source (from the device).
						</note>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="Refresh">
				<doc>
					<unmanaged>
						<line>public: virtual long refresh(</line>	
						<line>	unsigned long maxAge,</line>							
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>		
					</unmanaged>
					<remarks>
						<para>The returned value should be checked with SUCCEEDED or with FAILED.</para>	
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="DaSubscription">
				<doc>
					<unmanaged>
						<line>Not available! </line>
					</unmanaged>
				</doc>
			</method>
			<method name="GetObjectData">
				<doc>
					<unmanaged>
						<line>Not available! </line>						
					</unmanaged>
				</doc>
			</method>
		</class>
		<class name="DaSession">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT DaSession : virtual public ObjectSpaceElement</line>
				</unmanaged>
			</doc>
			<constructor name="DaSession">
				<doc>
					<unmanaged>
						<line>public: DaSession( const tstring&#38; url);</line>
					</unmanaged>
					<remarks>
						<para><b>Unmanaged C++</b></para><para>If a <b>DaSession</b> object was created using the <b>new</b> operator, the <b>delete</b> operator must be used to deallocate the memory for it. This operation must be done after the <b>terminate</b> method of the <b>Application</b> object was called.</para>
						<br></br>
						<para><b>Unmanaged C++</b></para><para>The following example shows how to create a new  <b>DaSession</b> object and ,in the end, deallocate the memory for it.</para>
						<code lang="Unmanaged C++">
...
using namespace SoftingOPCToolboxClient;
...
Application* application = getApplication();
	
if(SUCCEEDED(application->initialize())){
	
	//create a new DaSession object
	DaSession* session = new DaSession("opcda:///Softing.OPCToolboxDemo_ServerDA.1/{2E565242-B238-11D3-842D-0008C779D775}"));
	
	...
	//do some work here
	...
	application->terminate();	
	releaseApplication();
		
	//deallocates the memory allocated for the Dasession object
	delete session;							
}
						</code>	
						<para>
							<note>
								The url can be determined using the <b>Browse</b> method of a <b>ServerBrowser</b> object. The method returns an array of
								information on the OPC servers that can be found at a given IP address. Among other information the url of each server is
								returned.								
							</note>
						</para>
					</remarks>
				</doc>
			</constructor>
			<event name="ShutdownRequest">
				<doc>
					<unmanaged>
						<line>virtual unsigned char handleShutdownRequest(</line>
						<line>	const tstring&#38; reason</line>						
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="ReadCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleReadCompleted(</line>
						<line>	unsigned long executionContext,</line>	
						<line>	const std::vector&#60;tstring&#62;&#38; itemIds,</line>
						<line>	const std::vector&#60;tstring&#62;&#38; itemPaths,</line>
						<line>	const std::vector&#60;ValueQT*&#62;&#38; values,</line>
						<line>	const std::vector&#60;long&#62;&#38; results,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="WriteCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleWriteCompleted(</line>
						<line>	unsigned long executionContext,</line>	
						<line>	const std::vector&#60;tstring&#62;&#38; itemIds,</line>
						<line>	const std::vector&#60;tstring&#62;&#38; itemPaths,</line>
						<line>	const std::vector&#60;ValueQT*&#62;&#38; values,</line>
						<line>	const std::vector&#60;long&#62;&#38; results,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="GetStatusCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleGetStatusCompleted(</line>
						<line>	unsigned long executionContext,</line>												
						<line>	ServerStatus&#38; aServerStatus,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="BrowseCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleBrowseCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	unsigned long addressSpaceElementHandle,</line>												
						<line>	tstring&#38; addressSpaceElementId,</line>
						<line>	tstring&#38; addressSpaceElementPath,</line>
						<line>	std::vector&#60;DaAddressSpaceElement*&#62;&#38; addressSpaceElements,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</event>
			<event name="GetDaPropertiesCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleGetDaPropertiesCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	unsigned long addressSpaceElementHandle,</line>
						<line>	tstring&#38; addressSpaceElementId,</line>
						<line>	tstring&#38; addressSpaceElementPath,</line>
						<line>	std::vector&#60;DaProperty*&#62;&#38; someDaProperties,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</event>
			<event name="GetErrorStringCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleGetErrorStringCompleted(</line>
						<line>	unsigned long executionContext,</line>																
						<line>	long errorCode,</line>
						<line>	tstring&#38; errorString,</line>						
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="LogonCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleLogonCompleted(</line>
						<line>	unsigned long executionContext,</line>																
						<line>	tstring&#38; userName,</line>
						<line>	tstring&#38; password,</line>						
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="LogoffCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleLogoffCompleted(</line>
						<line>	unsigned long executionContext,</line>																
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<field name="m_subscriptionList">
					<doc>
						<unmanaged>
							<line>protected: std::map&#60;unsigned long,DaSubscription*&#62; m_daSubscriptionList;</line>						
						</unmanaged>
					</doc>
			</field>
			<property name="SubscriptionList">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;DaSubscription*&#62; getSubscriptionList( );</line>						
					</unmanaged>					
					<value>
						An array with all the subscriptions currently added to the session.
					</value>					
				</doc>
			</property>
			<property name="Url">
				<doc>
					<unmanaged>
						<line>public: virtual tstring getUrl( );</line>						
					</unmanaged>					
					<value>
						A string that represents the server's URL.
					</value>					
				</doc>
			</property>
			<property name="LocaleId">
				<doc>
					<unmanaged>
						<line>public: virtual tstring getUrl( );</line>	
						<line>public: virtual void setLocaleId(</line>
						<line>	tstring localeId</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents the language identifier.
					</value>					
				</doc>
			</property>
			<property name="ClientName">
				<doc>
					<unmanaged>
						<line>public: virtual tstring getClientName();</line>	
						<line>public: virtual void setClientName(</line>
						<line>	tstring clientName</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents the information about a client.
					</value>		
					<remarks>
						The specification recommends that the information about a client includes:
						<br></br>
						- the name of the executable file which contains the client (e.g "application.exe")
						<br></br>
						- the name of the computer on which the client is running (e.g "Visualization")
					</remarks>
				</doc>
			</property>
			<property name="SupportedOpcSpecification">
				<doc>
					<unmanaged>
						<line>public: virtual EnumOPCSpecification getSupportedOpcSpecification( );</line>													
					</unmanaged>					
					<value>
						One of the <b>EnumOPCSpecification</b> values.
					</value>					
				</doc>
			</property>
			<property name="ForcedOpcSpecification">
				<doc>
					<unmanaged>
						<line>public: virtual EnumOPCSpecification getForcedOpcSpecification( );</line>	
						<line>public: void setForcedOpcSpecification(</line>
						<line>	EnumOPCSpecification anOpcSpecification</line>
						<line>);</line>
					</unmanaged>					
					<value>
						One of the <b>EnumOPCSpecification</b> values.
					</value>					
				</doc>
			</property>
			<property name="ClassContext">
				<doc>
					<unmanaged>
						<line>public: virtual EnumClassContext getClassContext( );</line>
					</unmanaged>
					<value>
						One of the <b>EnumClassContext</b> values.
					</value>
				</doc>
			</property>
			<property name="RequestTimeout">
				<doc>
					<unmanaged>
						<line>public: virtual unsigned long getRequestTimeout();</line>
						<line>public: virtual void setRequestTimeout(unsigned long requestTimeout);</line>
					</unmanaged>
					<value>
						Timeout to be used in HTTP requests for XML-DA based communication.
					</value>
				</doc>
			</property>
			<property name="PerformInitialRead">
				<doc>
					<unmanaged>
						<line>public: virtual BOOL getPerformInitialRead();</line>
						<line>public: virtual void setPerformInitialRead(BOOL performInitialRead);</line>
					</unmanaged>
					<value>
						BOOL flag specifying whether to perform an initial read or not.
					</value>
				</doc>
			</property>
			<method name="RemoveDaSubscription">
				<doc>
					<unmanaged>
						<line>public: virtual long removeDaSubscription(</line>	
						<line>	DaSubscription* aSubscription</line>						
						<line>);</line>		
					</unmanaged>
					<remarks>
						<para>The returned value should be checked with SUCCEEDED or with FAILED.</para>
						<para><b>Unmanaged C++</b></para><para>Removing a <b>DaSubscription</b> object from session does not imply deallocating the memory
						it was allocated for it. Therefore, if a <b>DaSubscription</b> object was created using the <b>new</b> operator, the <b>delete</b> operator must be used to deallocate the memory for it.</para>						
					</remarks>
				</doc>
			</method>
			<method name="Read">
				<doc>
					<unmanaged>
						<line>public: virtual long read( </line>
						<line>	unsigned long maxAge,</line>
						<line>	std::vector&#60;tstring&#62; itemIDs,</line>
						<line>	std::vector&#60;tstring&#62; itemPaths,</line>
						<line>	std::vector&#60;ValueQT*&#62;&#38; values,</line>
						<line>	std::vector&#60;long&#62;&#38; results,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<para> The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.
						<br></br>
							If the server's cache contains a value newer than the specified maxAge, this value will be sent to the client.
							Otherwise the value will be taken directly from the data source(from device).
						</para>
						<para><b>Unmanaged C++</b></para><para>
						In the toolkit, memory is allocated for the <b>values</b> array and must be deallocated after finishing the reading operation. In case the reading is <b>synchronous</b> this must be undertaken by the person that uses the toolkit. In case the reading is <b>asynchronous</b> this memory is deallocated in the toolkit and nobody has to care about deallocating it.</para>
						<note> The method may be used only for the servers that support XML-DA or DA V3.0. For the servers that support only DA V2.0 or below, the method returns an error code indicating that the operation is not supported. In this case the <b>Read</b> method of the <b>DaSubscription</b> class should be used.</note> 
						<para>The following lines show how to synchronously read the values of some items using a DaSession object.</para>
						<code lang="Unmanaged C++">
...
using namespace SoftingOPCToolboxClient;
...
ExecutionOptions executionOptions;
executionOptions.setExecutionType(EnumExecutionType_SYNCHRONOUS);

std::vector&#60;tstring&#62; itemIdsForRead;
std::vector&#60;tstring&#62; itemPathsForRead;
unsigned long readCount = 3;
std::vector&#60;ValueQT*&#62; valuesToRead(readCount,NULL);
std::vector&#60;ValueQT*&#62;::iterator valuesToReadIterator;
std::vector&#60;long&#62; readResults(readCount,E_FAIL);

itemIdsForRead.push_back(_T("increment.UI1"));
itemIdsForRead.push_back(_T("maths.sin"));
itemIdsForRead.push_back(_T("time.local.second"));

itemPathsForRead.push_back(_T("increment.UI1"));
itemPathsForRead.push_back(_T("maths.sin"));
itemPathsForRead.push_back(_T("time.local.second"));

Application* application = getApplication();

session->connect(TRUE,FALSE,executionOptions);

if(SUCCEEDED(application->initialize())){
	
	//create a new DaSession object
	DaSession* session = new DaSession(_T("opcda:///Softing.OPCToolboxDemo_ServerDA.1/{2E565242-B238-11D3-842D-0008C779D775}"));
								
							
	if (SUCCEEDED(result = session->read(
								0,
								itemIdsForRead,
								itemPathsForRead,
								valuesToRead,
								readResults,
								&#38;executionOptions))){

		_tprintf(_T(" \nRead items using server \n"));	
		...
		//do something with the read values
		...
		
		//dealocate the memory allocated for the <b>valuesToRead</b> array
		for(valuesToReadIterator = valuesToRead.begin(); valuesToReadIterator != valuesToRead.end(); valuesToReadIterator++){

			if( *valuesToReadIterator != NULL)
				delete *valuesToReadIterator;

		} //end for

	} //end if
	...
	//do some work here
	...
	application->terminate();	
	releaseApplication();
									
	delete session;
}						
						</code>	
						<code lang="C#">
...
using Softing.OPCToolbox.Client;
using Softing.OPCToolbox;
...
static void Main(string[] args) {

	string[] itemIds = new string[] {"maths.sin","time.local.second","increment.UI1 array","increment.BSTR"};
	string[] itemPaths = new string[] {"maths.sin","time.local.second","increment.UI1 array","increment.BSTR"};
	ValueQT[] values;
	int[] results ;					
	ExecutionOptions executionOptions = new ExecutionOptions();
	
	Application application = Application.Instance;
	
	if(ResultCode.SUCCEEDED(application.Initialize())){
	
		//create a new DaSession object
		DaSession* session = new DaSession("opcda://localhost/Softing.OPCToolboxDemo_ServerDA/{2e565242-b238-11d3-842d-0008c779d775}")
																
		session.connect(true, false, executionOptions);									
		if (ResultCode.SUCCEEDED(session.Read(
								0,
								itemIds,
								itemPaths,
								out values,
								out results,
								executionOptions))){

			Console.WriteLine(" Session synchronous read succeeded!");
			...
			//do something with the read values
			...									
		} 
		else{
			Console.WriteLine(" Session synchronous read failed!");
		}//end if...else
		...
		//do some work here
		...
		application.Terminate();	
	} //end if
}//end Main					
						</code>
						<code lang="Visual Basic">
...
Imports Softing.OPCToolbox.Client	
Imports Softing.OPCToolbox
...
Shared Sub Main(ByVal args As String())

	Dim itemIds As String() = New String() {"maths.sin", "time.local.second", "increment.UI1 array", "increment.BSTR"}
	Dim itemPaths As String() = New String() {"maths.sin", "time.local.second", "increment.UI1 array", "increment.BSTR"}
	Dim values As ValueQT()
	Dim results As Integer()					
	Dim executionOptions As New ExecutionOptions
	
	Dim application As Application = Application.Instance
	
	If ResultCode.SUCCEEDED(application.Initialize()) Then
	
		//create a new DaSession object
			Dim session As New DaSession("opcda://localhost/Softing.OPCToolboxDemo_ServerDA/{2e565242-b238-11d3-842d-0008c779d775}")
												
		session.Connect(True, False, executionOptions)
		If ResultCode.SUCCEEDED(session.Read(
								Convert.ToUInt32(0), _
								itemIds, _
								itemPaths, _
								values, _
								results, _
								executionOptions)) Then

			Console.WriteLine(" Session synchronous read succeeded!");
			...
			//do something with the read values
			...									
			Else
				System.Console.WriteLine(" Session synchronous read failed!")
		End If
		...
		//do some work here
		...
		application.Terminate();	
	End If
End Sub			
						</code>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="Write">
				<doc>
					<unmanaged>
						<line>public: virtual long write( </line>
						<line>	std::vector&#60;tstring&#62; itemIDs,</line>
						<line>	std::vector&#60;tstring&#62; itemPaths,</line>
						<line>	std::vector&#60;ValueQT*&#62; values,</line>
						<line>	std::vector&#60;long&#62;&#38; results,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>); </line>
					</unmanaged>
					<summary>
					</summary>
					<remarks>
						<para>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.
						</para>
						There may be servers that do not support writing the quality and timestamp.
						<para><b>Unmanaged C++</b></para><para>
						 In this case the quality of the ValueQT object should be set to <b>EnumQuality.QUALITY_NOT_SET</b> and its timestamp to the default value.
						e.g
<code lang="Unmanaged C++">
Variant data;
DateTime writeDateTime;
data.setBSTR(_T("Softing"));
ValueQT valueToWrite = new ValueQT(data, EnumQuality_QUALITY_NOT_SET, writeDateTime);
</code>  						
						</para>
						<para>
 In this case the quality of the ValueQT object should be set to <b>EnumQuality.QUALITY_NOT_SET</b> and its timestamp to the default value.
e.g
<code lang="C#,Visual Basic,C++">
DateTime writeDateTime = new DateTime();
ValueQT valueToWrite = new ValueQT(11, EnumQuality.QUALITY_NOT_SET, writeDateTime);
</code>  
					</para>
					<para><b>Unmanaged C++</b></para><para>
						In the toolkit, memory is allocated for the <b>values</b> array and must be deallocated after finishing the writing operation. In case the writing is <b>synchronous</b> this must be undertaken by the person that uses the toolkit. In case the writing is <b>asynchronous</b> this memory is deallocated in the toolkit and nobody has to care about deallocating it.</para>
					<note> The method may be used only for the servers that support XML-DA or DA V3.0. For the servers that support only DA V2.0 or below, the method returns an error code indicating that the operation is not supported. In this case the <b>Write</b> method of the <b>DaSubscription</b> class should be used.</note>
					<para>The following lines show how to synchronously write a value for one item using a DaSession object.</para>	
<code lang="Unmanaged C++">
...
using namespace SoftingOPCToolboxClient;
...
ExecutionOptions executionOptions;
std::vector&#60;tstring&#62; itemIdsForWrite;
itemIdsForWrite.push_back(_T("increment.BSTR"));

std::vector&#60;tstring&#62; itemPathsForWrite;
unsigned long writeCount = 1;
std::vector&#60;ValueQT*&#62; valuesToWrite(writeCount,NULL);
std::vector&#60;ValueQT*&#62;::iterator valuesToWriteIterator;
std::vector&#60;long&#62; writeResults(writeCount,E_FAIL);
Variant data;
ValueQT* aValue;

Application* application = getApplication();

if(SUCCEEDED(application->initialize())){

//create a new DaSession object
DaSession* session = new DaSession(_T("opcda:///Softing.OPCToolboxDemo_ServerDA.1/{2E565242-B238-11D3-842D-0008C779D775}"));

executionOptions.setExecutionType(EnumExecutionType_SYNCHRONOUS);

session->connect(TRUE, FALSE, executionoptions);

	DateTime writeDateTime;
	data.setBSTR(_T("Softing"));
	aValue = new ValueQT(data, EnumQuality_QUALITY_NOT_SET, writeDateTime);
	
	valuesToWrite[0] = aValue;
	
	if (SUCCEEDED(result = session->write(
								itemIdsForWrite,
								itemPathsForWrite,
								valuesToWrite,
								writeResults,
								&#38;executionOptions))){

		_tprintf(_T(" \nWrite items using session \n"));
		...
		//do something here
		...
		
		//dealocate the memory allocated for the <b>valuesToWrite</b> array
		for(valuesToWriteIterator = valuesToWrite.begin(); valuesToWriteIterator != valuesToWrite.end(); valuesToWriteIterator++){

			if( *valuesToWriteIterator != NULL)
				delete *valuesToWriteIterator;

		} //end for

	} //end if
	...
	//do some work here
	...
	application->terminate();	
	releaseApplication();
									
	delete session;
}//end if				
						</code>	
						<code lang="C#">
...
using Softing.OPCToolbox.Client;
using Softing.OPCToolbox;
...
static void Main(string[] args) {

	ValueQT[] values = new ValueQT[1];	
	System.String aValue = "SOFTING";
	values[0] = new ValueQT(aValue, EnumQuality.QUALITY_NOT_SET, new DateTime());
	int[] results = new int[1];
	string[] itemIds = new string[]{"increment.BSTR"};
	ExecutionOptions executionOptions = new ExecutionOptions();
	
	Application application = Application.Instance;
	
	if(ResultCode.SUCCEEDED(application.Initialize())){
	
		//create a new DaSession object
		DaSession* session = new DaSession("opcda://localhost/Softing.OPCToolboxDemo_ServerDA/{2e565242-b238-11d3-842d-0008c779d775}");
												
		session.connect(true, false, executionOptions);
		if (ResultCode.SUCCEEDED(session.Write(															
								itemIds,
								null,
								values,
								out results,
								executionOptions))){

			Console.WriteLine(" Session synchronous write succeeded!");
			...
			//do something here
			...									
		} 
		else{
			Console.WriteLine(" Session synchronous write failed!");
		}//end if...else
		...
		//do some work here
		...
		application.Terminate();	
	} //end if
}//end Main					
						</code>
						<code lang="Visual Basic">
...
Imports Softing.OPCToolbox.Client	
Imports Softing.OPCToolbox
...
Shared Sub Main(ByVal args As String())								
	
	Dim application As Application = Application.Instance
	Dim executionOptions As New ExecutionOptions
	
	If ResultCode.SUCCEEDED(application.Initialize()) Then
	
		//create a new DaSession object
			Dim session As New DaSession("opcda://localhost/Softing.OPCToolboxDemo_ServerDA/{2e565242-b238-11d3-842d-0008c779d775}")	
			
		Dim values As ValueQT() = New ValueQT(1) {}
		values(0) = New ValueQT("SOFTING", EnumQuality.QUALITY_NOT_SET, new DateTime)
		Dim results As Integer() = New Integer(1) {}
		Dim itemIds As String() = New String() {"increment.BSTR"}
		
		session.Connect(True, False, executionOptions)									
		If ResultCode.SUCCEEDED(session.Write(
								itemIds, _
								Nothing, _															
								values, _
								results, _
								executionOptions)) Then

			Console.WriteLine(" Session synchronous read succeeded!");
			...
			//do something with the read values
			...									
			Else
				System.Console.WriteLine(" Session synchronous read failed!")
		End If
		...
		//do some work here
		...
		application.Terminate();	
	End If
End Sub			
						</code>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="Browse">
				<doc>
					<unmanaged>
						<line>public: virtual long browse( </line>
						<line>	tstring rootID, </line>
						<line>	tstring rootPath,  </line>
						<line>	DaAddressSpaceElementBrowseOptions* browseOptions, </line>
						<line>	std::vector&#60;DaAddressSpaceElement*&#62;&#38; addressSpaceElements, </line>
						<line>	ExecutionOptions* executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>						
						<para><b>Unmanaged C++</b></para><para>
						In the toolkit, memory is allocated for the <b>addressSpaceElements</b> array and must be deallocated after finishing the browsing operation. In case the browsing is <b>synchronous</b> this must be undertaken by the person that uses the toolkit. In case the browsing is <b>asynchronous</b> this memory is deallocated in the toolkit and nobody has to care about deallocating it.
						For deallocating memory see the code below:						
							<code lang="Unmanaged C++">
std::vector&#60;addressSpaceElements&#42;&#62;::iterator addressSpaceElementsIterator;
for(addressSpaceElementsIterator = addressSpaceElements.begin(); addressSpaceElementsIterator != addressSpaceElements.end(); addressSpaceElementsIterator++){
	delete (*addressSpaceElementsIterator);
} //end for
							</code>
						</para>
            <note>
              For servers that support XML-DA use the <b>Browse</b> method of the <b>DaAddressSpaceElement</b> class.
            </note>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>	
			<method name="GetDaProperties">
				<doc>
					<unmanaged>
						<line>public: virtual long getDaProperties( </line>
						<line>	tstring anAddressSpaceElementId, </line>
						<line>	tstring anAddressSpaceElementPath, </line>
						<line>	DaGetPropertiesOptions* aGetPropertyOptions, </line>
						<line>	std::vector&#60;DaProperty*&#62;&#38; someDaProperties, </line>
						<line>	ExecutionOptions* executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>
						<para><b>Unmanaged C++</b></para><para>
						In the toolkit, memory is allocated for the <b>someDaProperties</b> array and must be deallocated after finishing the getting propertis operation. In case the operation is <b>synchronous</b> this must be undertaken by the person that uses the toolkit. In case the operation is <b>asynchronous</b> this memory is deallocated in the toolkit and nobody has to care about deallocating it. The code below shows how the memory must be deallocated:						
							<code lang="Unmanaged C++">
std::vector&#60;DaProperty*&#42;&#62;::iterator someDaPropertiesIterator;
for(someDaPropertiesIterator = someDaProperties.begin(); someDaPropertiesIterator != someDaProperties.end(); someDaPropertiesIterator++){
	delete (*someDaPropertiesIterator);
} //end for
							</code>
						</para>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="GetStatus">
				<doc>
					<unmanaged>
						<line>public: virtual long getStatus( </line>
						<line>	ServerStatus&#38; serverStatus, </line>						
						<line>	ExecutionOptions* executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>												
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="ActivateConnectionMonitor">
				<doc>
					<unmanaged>
						<line>public: virtual long activateConnectionMonitor( </line>
						<line>	BOOL activate, </line>						
						<line>	unsigned long checkCycle, </line>
						<line>	unsigned long connect1Attempts, </line>						
						<line>	unsigned long connect1Cycle, </line>
						<line>	unsigned long connect2Cycle </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>												
					</remarks>
				</doc>
			</method>
			<method name="Logon">
				<doc>
					<unmanaged>
						<line>public: virtual long logon( </line>
						<line>	tstring userName, </line>	
						<line>	tstring password,</line>
						<line>	ExecutionOptions* executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>
						<note>In case of a XML-DA server first logon then connect and in case of a DA server first connect and then logon.</note>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="Logoff">
				<doc>
					<unmanaged>
						<line>public: virtual long logoff( </line>									
						<line>	ExecutionOptions* executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>												
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="GetErrorString">
				<doc>
					<unmanaged>
						<line>public: virtual long getErrorString( </line>	
						<line>	long errorCode,</line>
						<line>	tstring&#38; errorText,</line>
						<line>	ExecutionOptions* executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>												
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="DaSession">
				<doc>
					<unmanaged>
						<line>Not available! </line>						
					</unmanaged>
				</doc>
			</method>
			<method name="GetObjectData">
				<doc>
					<unmanaged>
						<line>Not available! </line>						
					</unmanaged>
				</doc>
			</method>
		</class>
		<class name="DaProperty">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT DaProperty </line>
				</unmanaged>
			</doc>
			<constructor name="DaProperty">
				<doc>
					<unmanaged>
						<line>public: DaProperty( );</line>
					</unmanaged>
				</doc>
			</constructor>
			<field name="m_id">
					<doc>
						<unmanaged>
							<line>protected: unsigned long m_id;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_name">
					<doc>
						<unmanaged>
							<line>protected: tstring m_name;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_itemId">
					<doc>
						<unmanaged>
							<line>protected: tstring m_itemId;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_itemPath">
					<doc>
						<unmanaged>
							<line>protected: tstring m_itemPath;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_description">
					<doc>
						<unmanaged>
							<line>protected: tstring m_description;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_dataType">
					<doc>
						<unmanaged>
							<line>protected: VARTYPE m_dataType;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_value">
					<doc>
						<unmanaged>
							<line>protected: ValueQT* m_value;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_result">
					<doc>
						<unmanaged>
							<line>protected: long m_result;</line>
						</unmanaged>
					</doc>
			</field>
			<property name="Id">
				<doc>
					<unmanaged>
						<line>public: unsigned long getId( );</line>
					</unmanaged>
					<value>
						An integer that represents an unique identifier for the property in the server's address space.
					</value>
				</doc>
			</property>
			<property name="Name">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getName( );</line>
					</unmanaged>
					<value>
						A string that represents a second identifier for the property in the server's address space.
					</value>
				</doc>
			</property>
			<property name="ItemId">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getItemId( );</line>
					</unmanaged>
					<value>
						A string that represents an unique identifier for the item to which the property belongs.
					</value>
				</doc>
			</property>
			<property name="ItemPath">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getItemPath( );</line>
					</unmanaged>
					<value>
						A string that represents an access path for the item to which the property belongs.
					</value>
				</doc>
			</property>
			<property name="Description">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getDescription( );</line>
					</unmanaged>
					<value>
						A string that represents a textual description of the property.
					</value>
				</doc>
			</property>
			<property name="DataType">
				<doc>
					<unmanaged>
						<line>public: VARTYPE getDataType( );</line>
					</unmanaged>
					<value>
						The type of the property value.
					</value>
				</doc>
			</property>
			<property name="ValueQT">
				<doc>
					<unmanaged>
						<line>public: ValueQT&#38; getValueQT( );</line>
					</unmanaged>
					<value>
						A <b>ValueQT</b> object that represents the property value together with its quality and timestamp.
					</value>
				</doc>
			</property>
			<property name="Result">
				<doc>
					<unmanaged>
						<line>public: long getResult( );</line>
					</unmanaged>
					<value>
						An integer that represents the result of getting the property value.
					</value>					
				</doc>
			</property>
		</class>
		<class name="DaGetPropertiesOptions">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT  DaGetPropertiesOptions </line>					
				</unmanaged>				
			</doc>
			<constructor name="DaGetPropertiesOptions">
				<doc>
					<unmanaged>
						<line>public: DaProperty( );</line>
					</unmanaged>
				</doc>
			</constructor>
			<field name="m_whatPropertyData">
					<doc>
						<unmanaged>
							<line>protected: EnumPropertyData m_whatPropertyData;</line>						
						</unmanaged>
					</doc>
			</field>
			<field name="m_pPropertyIds">
					<doc>
						<unmanaged>
							<line>protected: std::vector&#60;unsigned long&#62; m_pPropertyIds;</line>						
						</unmanaged>
					</doc>
			</field>
			<field name="m_pPropertyNames">
					<doc>
						<unmanaged>
							<line>protected: std::vector&#60;tstring&#62; m_pPropertyNames;</line>						
						</unmanaged>
					</doc>
			</field>
			<property name="WhatPropertyData">
				<doc>
					<unmanaged>
						<line>public: EnumPropertyData getWhatPropertyData( );</line>
						<line>public: void setWhatPropertyData(</line>
						<line>	EnumPropertyData somePropertyData</line>
						<line>);</line>
					</unmanaged>					
					<value>
						One of the <b>EnumPropertyData</b> values.
					</value>					
				</doc>
			</property>
			<property name="PropertyIds">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;unsigned long&#62;&#38; getPropertyIds();</line>		
						<line>public:void setPropertyIds(</line>	
						<line>	public: std::vector&#60;unsigned long&#62;&#38; propertyIds</line>	
						<line>);</line>	
					</unmanaged>					
					<value>
						A list with identifiers for an <b>DaItem</b>'s properties.
					</value>					
				</doc>
			</property>
			<property name="PropertyNames">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;tstring&#62;&#38; getPropertyNames( );</line>		
						<line>public: void setPropertyNames(</line>
						<line>std::vector&#60;tstring&#62;&#38; propertyNames</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A list with names for an <b>DaItem</b>'s properties.
					</value>					
				</doc>
			</property>
		</class>
		<class name="DaItem">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT DaItem : virtual public ObjectSpaceElement</line>					
				</unmanaged>	
				<remarks>
					The items are not the data sources - they are just connections to them. 
					The OPC Item should be thought of as simply specifying the address of the data, not as the actual physical source of the data that the address references.
				</remarks>
			</doc>
			<constructor name="DaItem">
				<doc>
					<unmanaged>
						<line>public: DaItem(</line>
						<line>	tstring itemId,</line>
						<line>	DaSubscription* parentSubscription);</line>
					</unmanaged>
					<remarks>
						<para><b>Unmanaged C++</b></para><para>If a <b>DaItem</b> object was created using the <b>new</b> operator, the <b>delete</b> operator must be used to deallocate the memory for it. This operation must be done after the <b>terminate</b> method of the <b>Application</b> object was called.</para>
						<br></br>
						<para><b>Unmanaged C++</b></para><para>The following example shows how to create a new  <b>DaItem</b> object and ,at the end, deallocate the memory for it.</para>
						<code lang="Unmanaged C++">
...
using namespace SoftingOPCToolboxClient;
...
Application* application = getApplication();
	
if(SUCCEEDED(application->initialize())){
	
	//create a new DaSession object
	DaSession* session = new DaSession(_T("opcda:///Softing.OPCToolboxDemo_ServerDA.1/{2E565242-B238-11D3-842D-0008C779D775}"));
			
	DaSubscription* subscription = new DaSubscription(1000, session);
							
	//create a new DaItem object
	DaItem item = new DaItem("increment.I1", subscription);
	...
	application->terminate();	
	releaseApplication();
		
	//deallocates the memory allocated for the Dasession object
	delete session;
	//dealocates the memory allocated for the DaSubscription object
	delete subscription;
	//dealocates the memory allocated for the DaItem object
	delete item;
}
						</code>		
					</remarks>
				</doc>
			</constructor>
			<event name="ValueChanged">
				<doc>
					<unmanaged>
						<line>virtual void handleValueChanged(</line>						
						<line>	const ValueQT&#38; aValueQT,</line>						
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<field name="m_subscription">
					<doc>
						<unmanaged>
							<line>protected: DaSession* m_session;</line>						
						</unmanaged>
					</doc>
			</field>
			<field name="m_valueQT">
					<doc>
						<unmanaged>
							<line>protected: DaSession* m_session;</line>						
						</unmanaged>
					</doc>
			</field>
			<property name="ValueQT">
				<doc>
					<unmanaged>
						<line>public: ValueQT* getValueQT( );</line>		
						<line>public: void setValueQT(</line>
						<line>	ValueQT* aValueQT</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A <b>ValueQT</b> object that represents the <b>DaItem</b>'s value,the value's quality and the time the value was read.
					</value>					
				</doc>
			</property>
			<property name="ValueToString">
				<doc>
					<unmanaged>
						<line>Not available!</line>								
					</unmanaged>					
					<value>
						 A string that represents the textual description of a <b>DaItem</b>'s value.
					</value>		
					<remarks>
						This property is used with a <b>DataControl</b>. It is the property to which the property of a Windows Forms Control is bound to.
					</remarks>
				</doc>
			</property>
			<property name="DaSubscription">
				<doc>
					<unmanaged>
						<line>public: DaSubscription* getDaSubscription( );</line>		
						<line>public: setDaSubscription(</line>
						<line>	DaSubscription* aDaSubscription</line>
						<line>);</line>								
					</unmanaged>					
					<value>
						 A <b>DaSubscription</b> object that represents the subscription to which the item belongs.
					</value>							
				</doc>
			</property>
			<property name="Id">
				<doc>
					<unmanaged>
						<line>public: tstring getId();</line>		
						<line>public: void setId(</line>
						<line>	tstring id</line>
						<line>);</line>								
					</unmanaged>					
					<value>
						A string that represents the item's unique identifier in the server's address space.
					</value>							
				</doc>
			</property>
			<property name="Path">
				<doc>
					<unmanaged>
						<line>public: tstring getPath();</line>		
						<line>public: void setPath(</line>
						<line>	tstring path</line>
						<line>);</line>								
					</unmanaged>					
					<value>
						A string that represents the communication path.
					</value>
					<remarks>
						The path is optional and therefore it can be omitted.
					</remarks>
				</doc>
			</property>
			<property name="NativeDatatype">
				<doc>
					<unmanaged>
						<line>public: VARTYPE getNativeDataType( );</line>													
					</unmanaged>					
					<value>
						The type of the data the item contains.
					</value>					
				</doc>
			</property>
			<property name="RequestedDatatype">
				<doc>
					<unmanaged>
						<line>public: VARTYPE getRequestedDataType( );</line>		
						<line>public: void setRequestedDataType(</line>
						<line>	VARTYPE requestedDataType</line>
						<line>);</line>								
					</unmanaged>					
					<value>
						The requested data type.
					</value>							
				</doc>
			</property>
			<property name="AccessRights">
				<doc>
					<unmanaged>
						<line>public: EnumAccessRights getAccessRights( );</line>														
					</unmanaged>					
					<value>
						One of the <b>EnumAccessRights</b> values.
					</value>							
				</doc>
			</property>
			<property name="Deadband">
				<doc>
					<unmanaged>
						<line>public: float getDeadband( );</line>	
						<line>public: void setDeadband(</line>
						<line>float deadband</line>
						<line>);</line>
					</unmanaged>					
					<value>
						The deadband to use when acquiring data from a source.
					</value>							
				</doc>
			</property>
			<property name="EUType">
				<doc>
					<unmanaged>
						<line>public: EnumEUType getEUType( );</line>							
					</unmanaged>					
					<value>
						One of the <b>EnumEUType</b> values.
					</value>							
				</doc>
			</property>
			<property name="EUInfo">
				<doc>
					<unmanaged>
						<line>public: Variant getEUInfo( );</line>							
					</unmanaged>					
					<value>
						The Engineering Unit Information.
					</value>							
				</doc>
			</property>		
			<method name="Read">
				<doc>
					<unmanaged>
						<line>public: virtual long read( </line>
						<line>	unsigned long maxAge,</line>					
						<line>	ValueQT&#38; itemValue,</line>
						<line>	long&#38; result,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>); </line>
					</unmanaged>
					<remarks>
						<para>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.
						<br></br>
							If the server's cache contains a value newer than the specified maxAge, this value will be sent to the client.
							Otherwise the value will be taken directly from the data source(from device).
						</para>
						<note>
							Unlike the <b>DaSubscription</b> and <b>DaSession</b> objects, the <b>DaItem</b> objects are not supplied as full-featured COM objects.
							Rather, they can be manipulated only if they belong to a <b>DaSubscription</b> object. Therefore, to use the <b>Read</b> method of a <b>DaItem</b> object, the item must be first added to a subscription.
						</note>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para><para>The following lines show how to synchronously read the values of an item.</para>
						<code lang="Unmanaged C++">
...
using namespace SoftingOPCToolboxClient;
...
ExecutionOptions executionOptions;
ValueQT itemValue;
long itemResult;

Application* application = getApplication();
	
if(SUCCEEDED(application->initialize())){
	
	//create a new DaSession object
	DaSession* session = new DaSession(_T("opcda:///Softing.OPCToolboxDemo_ServerDA.1/{2E565242-B238-11D3-842D-0008C779D775}"));
																	
	DaSubscription* subscription = new DaSubscription(1000, session);
	
	//add item to the existing subscription
	DaItem* item1 = new DaItem(_T("maths.sin"), subscription);
									
	executionOptions.setExecutionType(EnumExecutionType_SYNCHRONOUS);	
	if (SUCCEEDED(result = item1->read(
								100,
								itemValue,
								itemResult,
								&#38;executionOptions))){

		_tprintf(_T(" \nRead item \n"));	
		...
		//do something with the read value
		...
	} //end if
									
	application->terminate();	
	releaseApplication();
									
	delete session;
	delete subscription;
	delete item1;
}							
						</code>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="Write">
				<doc>
					<unmanaged>
						<line>public: virtual long write( </line>
						<line>	const ValueQT&#38; itemValue,</line>
						<line>	long result</line>
						<line>); </line>	
					</unmanaged>
					<remarks>
					<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para><para>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED.</b>
					</para>	
						There may be servers that do not support writing the quality and the timestamp.
						<para><b>Unmanaged C++</b></para><para>
						 In this case the quality of the ValueQT object should be set to <b>EnumQuality.QUALITY_NOT_SET</b> and its timestamp to the default value.
						e.g
<code lang="Unmanaged C++">
Variant data;
DateTime writeDateTime;
data.setBSTR(_T("Softing"));
ValueQT valueToWrite = new ValueQT(data, EnumQuality_QUALITY_NOT_SET, writeDateTime);
</code>  						
						</para>
						<para><b>C#, Visual Basic, C++</b></para><para>
 In this case the quality of the ValueQT object should be set to <b>EnumQuality.QUALITY_NOT_SET</b> and its timestamp to the default value.
e.g
<code lang="C#">
DateTime writeDateTime = new DateTime();
ValueQT valueToWrite = new ValueQT(11, EnumQuality.QUALITY_NOT_SET, writeDateTime);
</code>  
					</para>
					<note>
						Unlike the <b>DaSubscription</b> and <b>DaSession</b> objects, the <b>DaItem</b> objects are not supplied as full-featured COM objects.
						Rather, they can be manipulated only if they belong to a <b>DaSubscription</b> object. Therefore, to use the <b>Write</b> method of a <b>DaItem
						</b> object, the item must be first added to a subscription.
						</note>
					<para>The following lines show how to synchronously write an item's value.</para>
					</remarks>
				</doc>
			</method>
			<method name="DaItem">
				<doc>
					<unmanaged>
						<line>Not available! </line>
					</unmanaged>
				</doc>
			</method>
			<method name="GetObjectData">
				<doc>
					<unmanaged>
						<line>Not available! </line>
					</unmanaged>
				</doc>
			</method>
		</class>
		<class name="SubscriptionProperties">
			<doc>
				<unmanaged>
					<line>Not available!</line>
				</unmanaged>
			</doc>
			<constructor name="SubscriptionProperties">
				<doc>
					<unmanaged>
						<line>Not available!</line>
					</unmanaged>
				</doc>
			</constructor>
			<method name="Dispose">
				<doc>
					<unmanaged>
						<line>Not available!</line>
					</unmanaged>
				</doc>
			</method>
		</class>
		<class name="InfoCollector">
			<doc>
				<unmanaged>
					<line>Not available!</line>
				</unmanaged>
			</doc>
			<constructor name="InfoCollector">
				<doc>
					<unmanaged>
						<line>Not available!</line>
					</unmanaged>
				</doc>
			</constructor>
			<method name="Dispose">
				<doc>
					<unmanaged>
						<line>Not available!</line>
					</unmanaged>
				</doc>
			</method>
			<property name="InfoCollected">
				<doc>
					<unmanaged>
						<line>Not available!</line>
					</unmanaged>
					<value>
						A <b>ControlDaSession</b> object that represents the session chosen when the DataControl was configured.
					</value>
				</doc>
			</property>
		</class>
		<class name="ControlDaSession">
			<doc>
				<unmanaged>
					<line>Not available!</line>
				</unmanaged>
			</doc>
			<constructor name="ControlDaSession">
				<doc>
					<unmanaged>
						<line>Not available!</line>
					</unmanaged>
				</doc>
			</constructor>
			<field name="m_url">
					<doc>
						<unmanaged>
							<line>Not available!</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_binaryLicenseDa">
					<doc>
						<unmanaged>
							<line>Not available!</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_binaryLicenseXmlDa">
					<doc>
						<unmanaged>
							<line>Not available!</line>
						</unmanaged>
					</doc>
			</field>
			<property name="StoredUrl">
				<doc>
					<unmanaged>
						<line>Not available!</line>
					</unmanaged>
					<value>
						A string that represents the url.
					</value>
				</doc>
			</property>
			<method name="ControlDaSession">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</method>
			<method name="GetObjectData">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</method>
		</class>
		<class name="ControlDaSubscription">
			<doc>
				<unmanaged>
					<line>Not available!</line>					
				</unmanaged>					
			</doc>
			<constructor name="ControlDaSubscription">
				<doc>
					<unmanaged>
						<line>Not available!</line>
					</unmanaged>
				</doc>
			</constructor>
			<field name="m_name">
					<doc>
						<unmanaged>
							<line>Not available!</line>						
						</unmanaged>
					</doc>
			</field>
			<field name="m_updateRate">
					<doc>
						<unmanaged>
							<line>Not available!</line>						
						</unmanaged>
					</doc>
			</field>
			<field name="m_isActivated">
					<doc>
						<unmanaged>
							<line>Not available!</line>						
						</unmanaged>
					</doc>
			</field>
			<property name="StoredName">
				<doc>
					<unmanaged>
						<line>Not available!</line>						
					</unmanaged>					
					<value>
						A string that represents the name.
					</value>					
				</doc>
			</property>
			<property name="StoredUpdateRate">
				<doc>
					<unmanaged>
						<line>Not available!</line>						
					</unmanaged>					
					<value>
						The speed requested for scanning the active item objects.
					</value>					
				</doc>
			</property>
			<property name="IsActivated">
				<doc>
					<unmanaged>
						<line>Not available!</line>						
					</unmanaged>					
					<value>
						A boolean that shows whether the subscription is active is not.
					</value>					
				</doc>
			</property>
			<method name="ControlDaSubscription">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</method>
			<method name="GetObjectData">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</method>
		</class>
		<class name="ControlDaItem">
			<doc>
				<unmanaged>
					<line>Not available!</line>					
				</unmanaged>					
			</doc>
			<constructor name="ControlDaItem">
				<doc>
					<unmanaged>
						<line>Not available!</line>
					</unmanaged>
				</doc>
			</constructor>
			<field name="m_ID">
					<doc>
						<unmanaged>
							<line>Not available!</line>						
						</unmanaged>
					</doc>
			</field>					
			<property name="StoredId">
				<doc>
					<unmanaged>
						<line>Not available!</line>						
					</unmanaged>					
					<value>
						A string that represents an unique identifier for the <b>ControlDaItem</b> object in the server's address space.
					</value>					
				</doc>
			</property>
			<method name="ControlDaItem">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</method>
			<method name="GetObjectData">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</method>
			<delegate name="CancelAddNewEventHandler">
				<doc>
					<unmanaged>						
					</unmanaged>					
				</doc>
			</delegate>
			<event name="CancelAddNew">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</event>
			<method name="ControlDaItem">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</method>
			<method name="BeginEdit">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</method>
			<method name="EndEdit">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</method>
			<method name="CancelEdit">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</method>
		</class>
		<class name="DataControl">
			<doc>
				<unmanaged>
					<line>Not available!</line>					
				</unmanaged>					
			</doc>
			<constructor name="DataControl">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</constructor>
			<event name="DataChanged">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</event>	
			<event name="ListChanged">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</event>
			<event name="Disposed">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</event>
			<property name="Session">
				<doc>
					<unmanaged>
						<line>Not available!</line>						
					</unmanaged>					
					<value>
						A <b>ControDaSession</b> object that represents the session between the current client and the Data Access Server chosen when the control was configured.
					</value>					
				</doc>
			</property>
			<property name="BinaryLicenseDa">
				<doc>
					<unmanaged>
						<line>Not available!</line>						
					</unmanaged>					
					<value>
						A string that represents the license key for the binary Data Access licence.
					</value>					
				</doc>
			</property>
			<property name="BinaryLicenseXmlDa">
				<doc>
					<unmanaged>
						<line>Not available!</line>						
					</unmanaged>					
					<value>
						A string that represents the license key for the binary XML Data Access licence.
					</value>					
				</doc>
			</property>
			<method name="Start">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</method>
			<method name="Stop">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</method>
			<method name="GetItem">
				<doc>
					<unmanaged>
						<line>Not available!</line>							
					</unmanaged>					
				</doc>
			</method>
			<delegate name="ControlDataChangedEventHandler">
				<doc>
					<unmanaged>
					</unmanaged>					
				</doc>
			</delegate>
		</class>
		<class name="DaAddressSpaceElement">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT DaAddressSpaceElement : public AddressSpaceElement</line>
				</unmanaged>
			</doc>
			<constructor name="DaAddressSpaceElement">
				<doc>
					<unmanaged>
						<line>public: DaAddressSpaceElement();</line>
					</unmanaged>
				</doc>
			</constructor>
			<field name="m_itemPath">
				<doc>
					<unmanaged>
						<line>protected: tstring m_itemPath;</line>
					</unmanaged>
				</doc>
			</field>
			<field name="m_session">
				<doc>
					<unmanaged>
						<line>protected: DaSession* m_session;</line>
					</unmanaged>
				</doc>
			</field>
			<property name="ItemId">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getItemId( );</line>	
						<line>public: void setItemId(</line>
						<line>	tstring anItemId</line>
						<line>);</line>
					</unmanaged>
					<value>
						A string that represents the element's unique identifier in the server's address space.
					</value>
				</doc>
			</property>
			<property name="ItemPath">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getItemPath( );</line>	
						<line>public: void setItemPath(</line>
						<line>	tstring anItemPath</line>
						<line>);</line>
					</unmanaged>
					<value>
						A string that represents a second identifier for the element in the server's address space.
					</value>
				</doc>
			</property>
			<property name="Session">
				<doc>
					<unmanaged>
						<line>public: DaSession* getSession( );</line>	
						<line>public: setSession(</line>
						<line>	DaSession* aSession</line>
						<line>);</line>	
					</unmanaged>
					<value>
						A <b>DaSession</b> object to whom the element belongs.
					</value>
				</doc>
			</property>
			
			<property name="IsItem">
				<doc>
					<unmanaged>
						<line>public: bool isItem(void);</line>
					</unmanaged>
					<value>
						true if the element is an item
					</value>
				</doc>
			</property>
			
			<method name="Browse">
				<doc>
					<unmanaged>
						<line>public: virtual long browse(</line>
						<line>	DaAddressSpaceElementBrowseOptions* browseOptions,</line>
						<line>	std::vector&#60;DaAddressSpaceElement*&#62;&#38; addressSpaceElements,</line>
						<line>	ExecutionOptions* executionOptions</line>	
						<line>);</line>
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>
						<para><b>Unmanaged C++</b></para><para>
						In the toolkit, memory is allocated for the <b>addressSpaceElements</b> array. Therefore this memory must be deallocated after finishing the browsing operation. The following lines show how to o this.						
							<code lang="Unmanaged C++">
std::vector&#60;addressSpaceElements&#42;&#62;::iterator addressSpaceElementsIterator;
for(addressSpaceElementsIterator = addressSpaceElements.begin(); addressSpaceElementsIterator != addressSpaceElements.end(); addressSpaceElementsIterator++){
	delete (*addressSpaceElementsIterator);
} //end for
							</code>
						</para>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="GetDaProperties_1">
				<doc>
					<unmanaged>
						<line>public: virtual long getDaProperties(</line>	
						<line>	DaGetPropertiesOptions* aDaGetPropertiesOptions,</line>
						<line>	std::vector&#60;DaProperty*&#62;&#38; someDaProperties,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>
						<para> Before calling this method make sure to set the session to whom the element belongs.</para>
						<para><b>Unmanaged C++</b></para><para>
						In the toolkit, memory is allocated for the <b>someDaProperties</b> array. Therefore this memory must be deallocated after finishing the getting properties operation. The lines below show how to do this.							
							<code lang="Unmanaged C++">
std::vector&#60;DaProperty*&#62;::iterator someDaPropertiesIterator;
for(someDaPropertiesIterator = someDaProperties.begin(); someDaPropertiesIterator != someDaProperties.end(); someDaPropertiesIterator++){
	delete (*someDaPropertiesIterator);
} //end for
							</code>
						</para>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="GetDaProperties_2">
				<doc>
					<unmanaged>
						<line>public: virtual long getDaProperties(</line>	
						<line>	std::vector&#60;DaProperty*&#62;&#38; someDaProperties,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>
						<para> Before calling this method make sure to set the session to whom the element belongs.</para>
						<para><b>Unmanaged C++</b></para><para>
						In the toolkit, memory is allocated for the <b>someDaProperties</b> array. Therefore this memory must be deallocated after finishing the getting properties operation. The lines below show how to do this.							
							<code lang="Unmanaged C++">
std::vector&#60;DaProperty*&#62;::iterator someDaPropertiesIterator;
for(someDaPropertiesIterator = someDaProperties.begin(); someDaPropertiesIterator != someDaProperties.end(); someDaPropertiesIterator++){
	delete (*someDaPropertiesIterator);
} //end for
							</code>
						</para>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>			
		</class>
		<class name="AeSubscription">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT AeSubscription : public ObjectSpaceElement</line>
				</unmanaged>	
			</doc>			
			<constructor name="AeSubscription">
			
				<doc>
					<unmanaged>
						<line>public: AeSubscription(AeSession* parentSession );</line>
					</unmanaged>
					<remarks>
						<para><b>Unmanaged C++</b></para><para>If an <b>AeSubscription</b> object was created using the <b>new</b> operator, the <b>delete</b> operator must be used to deallocate the memory for it. This operation must be done after the <b>terminate</b> method of the <b>Application</b> class was called.</para>
						<br></br>
						<para><b>Unmanaged C++</b></para><para>The following example shows how to create a new  <b>AeSubscription</b> object and ,at the end, deallocate the memory for it.</para>
						<code lang="Unmanaged C++">
...
using namespace SoftingOPCToolboxClient;
...
Application* application = getApplication();
	
if(SUCCEEDED(application->initialize())){
	
	//create a new AeSession object
	AeSession* session = new AeSession("opcae:///Softing.OPCToolboxDemo_ServerAE.1/{2E565243-B238-11D3-842D-0008C779D775}");
	
	AeSubscription* subscription = new AeSubscription(session);
	...
	application->terminate();
	releaseApplication();
		
	//deallocates the memory allocated for the AeSession object
	delete session;
	//dealocates the memory allocated for the AeSubscription object
	delete subscription;
}
						</code>		
					</remarks>
				</doc>
			</constructor>	
			<event name="AeEventsReceived">
				<doc>
					<unmanaged>
						<line>virtual void handleAeEventsReceived(</line>
						<line>	BOOL isRefresh,</line>
						<line>	BOOL lastRefresh,</line>
						<line>	const std::vector&#60;AeEvent*&#62;&#38; events,</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</event>
			<event name="RefreshAeConditionsCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleRefreshAeConditionsCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</event>
			<event name="CancelRefreshAeConditionsCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleCancelRefreshAeConditionsCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</event>
			<event name="AeConditionsChanged">
				<doc>
					<unmanaged>
						<line>virtual void handleAeConditionsChanged(</line>
						<line>	const std::vector&#60;AeCondition*&#62;&#38; someAeConditions</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</event>
			<field name="m_session">
				<doc>
					<unmanaged>
						<line>protected: AeSession* m_session;</line>
					</unmanaged>
				</doc>
			</field>
			<field name="m_conditionList">
				<doc>
					<unmanaged>
						<line>protected: std::vector&#60;AeCondition*&#62; m_conditionList;</line>
					</unmanaged>
				</doc>
			</field>
			<property name="AeSession">
				<doc>
					<unmanaged>
						<line>public: AeSession* getAeSession( );</line>
						<line>public: void setAeSession(</line>
						<line>	AeSession* aSession</line>
						<line>);</line>
					</unmanaged>
					<value>
						An <b>AeSession</b> object that represents the session to whom the subscription belongs.
					</value>
				</doc>
			</property>	
			<property name="RequestedBufferTime">
				<doc>
					<unmanaged>
						<line>public: unsigned long getRequestedBufferTime( );</line>
						<line>public: void setRequestedBufferTime(</line>
						<line>	unsigned long requestedBufferTime</line>
						<line>);</line>
					</unmanaged>
					<value>
						An integer that represents the requested time interval(in ms) at which the events to be sent to the client.
					</value>
				</doc>
			</property>
			<property name="RevisedBufferTime">
				<doc>
					<unmanaged>
						<line>public: unsigned long getRevisedBufferTime( );</line>
					</unmanaged>
					<value>
						An integer that represents the actual time interval(in ms) at which the events to be sent to the client.
					</value>
				</doc>
			</property>
			<property name="RequestedMaxSize">
				<doc>
					<unmanaged>
						<line>public: unsigned long getRequestedMaxSize( );</line>
						<line>public: void setRequestedMaxSize(</line>
						<line>	unsigned long maxSize</line>
						<line>);</line>
					</unmanaged>
					<value>
						An integer that represents the requested length of the event queue in the server.
					</value>
				</doc>
			</property>
			<property name="RevisedMaxSize">
				<doc>
					<unmanaged>
						<line>public: unsigned long getRevisedMaxSize( );</line>
					</unmanaged>
					<value>
						An integer that represents the actual length of the event queue in the server.
					</value>
				</doc>
			</property>
			<property name="FilterSeverityLow">
				<doc>
					<unmanaged>
						<line>public: unsigned long getFilterSeverityLow( );</line>
						<line>public: void setFilterSeverityLow(</line>
						<line>	unsigned long filterSeverityLow</line>
						<line>);</line>
					</unmanaged>
					<value>
						An integer that represents the criteria of filtering events with low severity.
					</value>
				</doc>
			</property>
			<property name="FilterSeverityHigh">
				<doc>
					<unmanaged>
						<line>public: unsigned long getFilterSeverityHigh( );</line>
						<line>public: void setFilterSeverityHigh(</line>
						<line>	unsigned long filterSeverityHigh</line>
						<line>);</line>
					</unmanaged>
					<value>
						An integer that represents the criteria of filtering events with high severity.
					</value>
				</doc>
			</property>
			<property name="FilterEventTypes">
				<doc>
					<unmanaged>
						<line>public: unsigned long getFilterEventTypes( );</line>
						<line>public: void setFilterEventTypes(</line>
						<line>	unsigned long filterEventTypes</line>
						<line>);</line>
					</unmanaged>
					<value>
						An integer that represents the criteria of filtering events based on the values of their types.
					</value>
				</doc>
			</property>
			<property name="FilterCategories">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;unsigned long&#62; getFilterCategories( );</line>
						<line>public: void setFilterCategories(</line>
						<line>	std::vector&#60;unsigned long&#62; filterCategories</line>
						<line>);</line>
					</unmanaged>
					<value>
						An array of integers that represents event categories.
					</value>
				</doc>
			</property>
			<property name="FilterAreas">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;tstring&#62; getFilterAreas( );</line>
						<line>public: void setFilterAreas(</line>
						<line>	std::vector&#60;tstring&#62; filterAreas</line>
						<line>);</line>
					</unmanaged>
					<value>
						An array of strings that represents the areas in which the events occur.
					</value>
				</doc>
			</property>
			<property name="FilterSources">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;tstring&#62; getFilterSources( );</line>
						<line>public: void setFilterSources(</line>
						<line>	std::vector&#60;tstring&#62; filterSources</line>
						<line>);</line>
					</unmanaged>
					<value>
						An array of strings that represents the sources that produce events.
					</value>
				</doc>
			</property>
			<property name="ReturnedAttributes">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;AeReturnedAttributes*&#62; getReturnedAttributes( );</line>
						<line>public: void setReturnedAttributes(</line>
						<line>	std::vector&#60;AeReturnedAttributes*&#62; someAeReturnedAttributes</line>
						<line>);</line>
					</unmanaged>
					<value>
						An array of <b>AeReturnedAttributes</b> objects that represents the list of optional attributes to be sent with the event notification.
					</value>	
					<remarks><b>Unmanaged C++</b>
						The <b>getReturnedAttributes</b> method returns an array of <b>AeReturnedAttributes</b> objects for which memory was allocated in the toolkit. Therefore, in the end, the memory must be deallocated like in the statement below:
						<code lang="Unmanaged C++">
							
std::vector&#60;AeReturnedAttributes*&#62; returnedAttributes;
std::vector&#60;AeReturnedAttributes*&#62;::iterator returnedAttributesIterator;

//get the returned attributes
returnedAttributes =  subscription.getReturnedAttributes();	
...
//do something with the returned attributes
...
//deallocate memory
for(returnedAttributesIterator = returnedAttributes.begin(); returnedAttributesIterator != returnedAttributes.end(); returnedAttributesIterator++){
	delete (*returnedAttributesIterator);
}
						</code>
					</remarks>
				</doc>
			</property>
			<property name="AeConditionList">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;AeCondition*&#62;&#38; getAeConditionList( );</line>
					</unmanaged>
					<value>
						A list with all active and/or not acknowledged condition-related events.
					</value>	
					<remarks>
						<para><b>Unmanaged C++</b></para><para>The list of conditions is automatically destroyed when the subscription to whom it belongs is destroyed. No other special statement is necessary for deallocating the memory allocated for the conditions list.
						</para>
					</remarks>
				</doc>
			</property>
			<method name="RefreshAeConditions">
				<doc>
					<unmanaged>
						<line>public: virtual long refreshAeConditions( </line>
						<line>	ExecutionOptions* executionOptions </line>
						<line>); </line>
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="CancelRefreshAeConditions">
				<doc>
					<unmanaged>
						<line>public: virtual long cancelRefreshAeConditions( </line>
						<line>	ExecutionOptions* executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
		</class>
		<class name="AeReturnedAttributes">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT AeReturnedAttributes</line>
				</unmanaged>	
			</doc>			
			<constructor name="AeReturnedAttributes">
				<doc>
					<unmanaged>
						<line>public: AeReturnedAttributes( );</line>
					</unmanaged>
				</doc>
			</constructor>
			<field name="m_categoryId">
					<doc>
						<unmanaged>
							<line>protected: uint m_categoryId;</line>
						</unmanaged>
					</doc>
			</field>
			<field name="m_attributesIds">
					<doc>
						<unmanaged>
							<line>protected: uint[] m_attributesIds;</line>
						</unmanaged>
					</doc>
			</field>
			<property name="CategoryId">
				<doc>
					<unmanaged>
						<line>public: unsigned long getCategoryId( );</line>
						<line>public: void setCategoryId(</line>
						<line>	unsigned long categoryId</line>
						<line>);</line>
					</unmanaged>
					<value>
						An integer that represents an identifier for the category to whom the event belongs.
					</value>
				</doc>
			</property>
			<property name="AttributeIds">
				<doc>
					<unmanaged>
						<line>public: const std::vector&#60;unsigned long&#62;&#38; getAttributesIds( );</line>
						<line>public: void setAttributesIds(</line>
						<line>	std::vector&#60;unsigned long&#62; attributesIds</line>
						<line>);</line>
					</unmanaged>
					<value>
						An array of strings that represents the sources that produce events.
					</value>
				</doc>
			</property>
		</class>
		<class name="AeSession">
			<doc>
				<unmanaged>
					<line>class TBC_EXPORT AeSession : public ObjectSpaceElement</line>
				</unmanaged>	
			</doc>			
			<constructor name="AeSession">
				<doc>
					<unmanaged>
						<line>public: AeSession( const tstring&#38; url);</line>
					</unmanaged>
					<remarks>
						<para><b>Unmanaged C++</b></para><para>If an <b>AeSession</b> object was created using the <b>new</b> operator, the <b>delete</b> operator must be used to deallocate the memory for it. This operation must be done after the <b>terminate</b> method of the <b>Application</b> class was called.</para>
						<br></br>
						<para><b>Unmanaged C++</b></para><para>The following example shows how to create a new  <b>AeSession</b> object and ,at the end, deallocate the memory for it.</para>
						<code lang="Unmanaged C++">
...
using namespace SoftingOPCToolboxClient;
...
Application* application = getApplication();
	
if(SUCCEEDED(application->initialize())){
	
//create a new AeSession object
AeSession* session = new AeSession("opcae:///Softing.OPCToolboxDemo_ServerAE.1/{2E565243-B238-11D3-842D-0008C779D775}");
...

application->terminate();	
releaseApplication();
		
//deallocates the memory allocated for the AeSession object
	delete session;
}
						</code>
						<para>
							<note>
								A server's url can be determined using the <b>Browse</b> method of a <b>ServerBrowser</b> object. The method returns an array of
								information on the OPC servers that can be found at a given IP address. Among other information the url of each server is
								returned.
							</note>
						</para>		
					</remarks>
				</doc>
			</constructor>	
			<field name="m_subscriptionList">
					<doc>
						<unmanaged>
							<line>protected: uint[] m_attributesIds;</line>
						</unmanaged>
					</doc>
			</field>
			<event name="ShutdownRequest">
				<doc>
					<unmanaged>
						<line>virtual unsigned char handleShutdownRequest(</line>
						<line>	const tstring&#38; reason,</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</event>
			<event name="GetServerStatusCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleGetStatusCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	ServerStatus&#38; aServerStatus,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>
				</doc>
			</event>
			<event name="BrowseCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleBrowseCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	unsigned long addressSpaceElementHandle,</line>
						<line>	std&#58;&#58;vector&#60;AddressSpaceElement*&#62;&#38; addressSpaceElements,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="QueryAeCategoriesCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleQueryAeCategoriesCompleted(</line>
						<line>	unsigned long executionContext,</line>						
						<line>	std&#58;&#58;vector&#60;AeCategory*&#62;&#38; categories,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="QueryAvailableAeFiltersCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleQueryAvailableAeFiltersCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	EnumFilterBy availableFilters,</line>					
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="EnableAeConditionsByAreaCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleEnableAeConditionsByAreaCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	BOOL enable,</line>
						<line>	tstring&#38; area,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="EnableAeConditionsBySourceCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleEnableAeConditionsBySourceCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	BOOL enable,</line>
						<line>	tstring&#38; source,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="AcknowledgeAeConditionsCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleAcknowledgeAeConditionsCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	tstring&#38; ackId,</line>
						<line>	tstring&#38; ackComment,</line>
						<line>	std::vector&#60;AeCondition&#42;&#62;&#38; someAeConditions,</line>
						<line>	std::vector&#60;long&#62;&#38; results,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="QueryAeSourceConditionsCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleQueryAeSourceConditionsCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	tstring&#38; sourceName,</line>
						<line>	std&#58;&#58;vector&#60;tstring;&#62;&#38; conditionNames,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="GetAeConditionStateCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleGetAeConditionStateCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	tstring&#38; sourcePath,</line>
						<line>	tstring&#38; conditionName,</line>
						<line>	std&#58;&#58;vector&#60;unsigned long&#62;&#38; attributesIds,</line>
						<line>	AeConditionState&#38; conditionState,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="GetErrorStringCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleGetErrorStringCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	long errorCode,</line>
						<line>	tstring&#38; errorText,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="LogonCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleLogonCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	tstring&#38; userName,</line>
						<line>	tstring&#38; password,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="LogoffCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleLogoffCompleted(</line>
						<line>	unsigned long executionContext,</line>					
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<property name="SubscriptionList">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;AeSubscription*&#62; getSubscriptionList( )</line>						
					</unmanaged>					
					<value>
						An array with the <b>Subscription</b> objects currently added to the session.
					</value>					
				</doc>
			</property>
			<property name="Url">
				<doc>
					<unmanaged>
						<line>public: virtual tstring getUrl( );</line>						
					</unmanaged>					
					<value>
						A string that represents the server's url.
					</value>					
				</doc>
			</property>
			<property name="LocaleId">
				<doc>
					<unmanaged>
						<line>public: virtual tstring getLocaleId( );</line>
						<line>public: virtual void setLocaleId(</line>
						<line>	tstring localeId</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents the valid language identifier for the current server.
					</value>					
				</doc>
			</property>
			<property name="ClientName">
				<doc>
					<unmanaged>
						<line>public: virtual tstring getClientName( );</line>
						<line>public: virtual void setClientName(</line>
						<line>	tstring clientName</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents the information about a client.
					</value>	
					<remarks>
						The specification recommends that the information about a client includes:
						<br></br>
						- the name of the executable file which contains the client (e.g "application.exe")
						<br></br>
						- the name of the computer on which the client is running (e.g "Visualization")
					</remarks>
				</doc>
			</property>
			<property name="ClassContext">
				<doc>
					<unmanaged>
						<line>public: virtual EnumClassContext getClassContext( );</line>
						<line>public: virtual void setClassContext(</line>
						<line>	EnumClassContext aClassContext</line>
						<line>);</line>
					</unmanaged>					
					<value>
						One of the <b>EnumClassContext</b> values. 
					</value>					
				</doc>
			</property>				
			<method name="RemoveAeSubscription">
				<doc>
					<unmanaged>
						<line>public: virtual long removeAeSubscription(</line>
						<line>	AeSubscription* aSubscription</line>
						<line>);</line>
					</unmanaged>				
					<remarks>
						<para>The returned value should be checked with SUCCEEDED or with FAILED.</para>
						<para><b>Unmanaged C++</b></para><para>Removing an <b>AeSubscription</b> object from session does not imply deallocating the memory
						it was allocated for it. Therefore, if an <b>AeSubscription</b> object was created using the <b>new</b> operator, the <b>delete</b> operator must be used to deallocate the memory for it.</para>						
					</remarks>
				</doc>
			</method>
			<method name="GetStatus">
				<doc>
					<unmanaged>
						<line>public: virtual long getStatus(</line>
						<line>	ServerStatus&#38; serverStatus,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>
					</unmanaged>				
					<remarks>
						The returned value should be checked with SUCCEEDED or with FAILED.
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="Browse">
				<doc>
					<unmanaged>
						<line>public: virtual long browse( </line>
						<line>	AddressSpaceElement* addressSpaceElement, </line>
						<line>	AddressSpaceElementBrowseOptions* browseOptions, </line>
						<line>	std::vector&#60;AddressSpaceElement*&#62;&#38; addressSpaceElements, </line>
						<line>	ExecutionOptions* executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>												
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>						
						<para><b>Unmanaged C++</b></para><para>
						In the toolkit, memory is allocated for the <b>addressSpaceElements</b> array and must be deallocated after finishing the browsing operation. In case the browsing is <b>synchronous</b> this must be undertaken by the person that uses the toolkit. In case the browsing is <b>asynchronous</b> this memory is deallocated in the toolkit and nobody has to care about deallocating it. The memory must be deallocated like in the statement below:						
							<code lang="Unmanaged C++">
std::vector&#60;addressSpaceElements&#42;&#62;::iterator addressSpaceElementsIterator;
for(addressSpaceElementsIterator = addressSpaceElements.begin(); addressSpaceElementsIterator != addressSpaceElements.end(); addressSpaceElementsIterator++){
	delete (*addressSpaceElementsIterator);
} //end for
							</code>
						</para>					
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="QueryAeCategories">
				<doc>
					<unmanaged>
						<line>public: virtual long queryAeCategories(</line>
						<line>	std::vector&#60;AeCategory*&#62;&#38; categories,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>
					</unmanaged>				
					<remarks>
						The returned value should be checked with SUCCEEDED or with FAILED.
						<para><b>Unmanaged C++</b></para><para>
						In the toolkit, memory is allocated for the <b>categories</b> array and must be deallocated after finishing the query categories operation. In case the operation is <b>synchronous</b> this must be undertaken by the person that uses the toolkit. In case the operation is <b>asynchronous</b> this memory is deallocated in the toolkit and nobody has to care about deallocating it.</para>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="QueryAvailableAeFilters">
				<doc>
					<unmanaged>
						<line>public: virtual long queryAvailableAeFilters(</line>
						<line>	EnumFilterBy&#38; availableFilters,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>
					</unmanaged>				
					<remarks>
						The returned value should be checked with SUCCEEDED or with FAILED.
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="EnableAeConditionsByArea">
				<doc>
					<unmanaged>
						<line>public: virtual long enableAeConditionsByArea(</line>
						<line>	std::vector&#60;tstring&#62;&#38; areas,</line>
						<line>	BOOL enable,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>
					</unmanaged>				
					<remarks>
						The returned value should be checked with SUCCEEDED or with FAILED.
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="EnableAeConditionsBySource">
				<doc>
					<unmanaged>
						<line>public: virtual long enableAeConditionsBySource(</line>
						<line>	std::vector&#60;tstring&#62;&#38; sources,</line>
						<line>	BOOL enable,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>
					</unmanaged>				
					<remarks>
						The returned value should be checked with SUCCEEDED or with FAILED.
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="AcknowledgeAeConditions">
				<doc>
					<unmanaged>
						<line>public: virtual long acknowledgeAeConditions(</line>
						<line>	const tstring&#38; ackId,</line>
						<line>	const tstring&#38; ackComment,</line>
						<line>	std::vector&#60;AeCondition*&#62;&#38; conditions,</line>
						<line>	std::vector&#60;long&#62;&#38; results,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>
					</unmanaged>				
					<remarks>
						The returned value should be checked with SUCCEEDED or with FAILED.
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="QueryAeSourceConditions">
				<doc>
					<unmanaged>
						<line>public: virtual long queryAeSourceConditions(</line>
						<line>	tstring&#38; sourceName,</line>
						<line>	std::vector&#60;tstring&#62;&#38; conditionNames,</line>						
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>
					</unmanaged>				
					<remarks>
						The returned value should be checked with SUCCEEDED or with FAILED.
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="GetAeConditionState">
				<doc>
					<unmanaged>
						<line>public: virtual long getAeConditionState(</line>
						<line>	tstring&#38; sourcePath,</line>
						<line>	tstring&#38; conditionName,</line>
						<line>	std::vector&#60;AeAttribute*&#62;&#38; attributes,</line>
						<line>	AeConditionState&#38; conditionState,</line>
						<line>	ExecutionOptions* executionOptions</line>
						<line>);</line>
					</unmanaged>				
					<remarks>
						The returned value should be checked with SUCCEEDED or with FAILED.
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="ActivateConnectionMonitor">
				<doc>
					<unmanaged>
						<line>public: virtual long activateConnectionMonitor(</line>
						<line>	BOOL activate,</line>
						<line>	unsigned long checkCycle,</line>
						<line>	unsigned long connect1Attempts,</line>
						<line>	unsigned long connect1Cycle,</line>
						<line>	unsigned long connect2Cycle</line>
						<line>);</line>
					</unmanaged>				
					<remarks>
						The returned value should be checked with SUCCEEDED or with FAILED.
					</remarks>
				</doc>
			</method>
			<method name="GetErrorString">
				<doc>
					<unmanaged>
						<line>public: virtual long getErrorString(</line>
						<line>	long errorCode,</line>
						<line>	tstring&#38; errorText,</line>
						<line>	ExecutionOptions* executionOptions</line>						
						<line>);</line>
					</unmanaged>				
					<remarks>
						The returned value should be checked with SUCCEEDED or with FAILED.
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="Logon">
				<doc>
					<unmanaged>
						<line>public: virtual long logon(</line>
						<line>	tstring&#38; userName,</line>
						<line>	tstring&#38; password,</line>
						<line>	ExecutionOptions* executionOptions</line>						
						<line>);</line>
					</unmanaged>				
					<remarks>
						The returned value should be checked with SUCCEEDED or with FAILED.
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
					
				</doc>
			</method>
			<method name="Logoff">
				<doc>
					<unmanaged>
						<line>public: virtual long logoff(</line>					
						<line>	ExecutionOptions* executionOptions</line>						
						<line>);</line>
					</unmanaged>				
					<remarks>
						The returned value should be checked with SUCCEEDED or with FAILED.
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>			
		</class>
		<class name="AeEvent">
				<doc>
					<unmanaged>
						<line>class TBC_EXPORT AeEvent</line>
					</unmanaged>	
				</doc>
			<constructor name="AeEvent">
				<doc>
					<unmanaged>
						<line>public: AeEvent( )</line>
					</unmanaged>	
				</doc>
			</constructor>
			<field name="m_eventType">
				<doc>
					<unmanaged>
						<line>protected: EnumEventType m_eventType;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_eventCategory">
				<doc>
					<unmanaged>
						<line>protected: unsigned long m_eventCategory;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_severity">
				<doc>
					<unmanaged>
						<line>protected: unsigned long m_severity;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_sourcePath">
				<doc>
					<unmanaged>
						<line>protected: tstring m_sourcePath;</line>
					</unmanaged>					
				</doc>
			</field>
			<field name="m_message">
				<doc>
					<unmanaged>
						<line>protected: tstring m_message;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_occurenceTime">
				<doc>
					<unmanaged>
						<line>protected: DateTime m_occurenceTime;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_eventAttributes">
				<doc>
					<unmanaged>
						<line>protected: std::vector&#60;Variant*&#62; m_eventAttributes;</line>
					</unmanaged>	
					<value>
						An array with additional vendor-specific attributes to be sent with the event notification.
					</value>
				</doc>
			</field>
			<field name="m_actorId">
				<doc>
					<unmanaged>
						<line>protected: tstring m_actorId;</line>
					</unmanaged>						
				</doc>
			</field>	
			<property name="EventType">
				<doc>
					<unmanaged>
						<line>public: EnumEventType getEventType( );</line>
						<line>public: virtual void setEventType(</line>
						<line>	EnumEventType anEventType</line>
						<line>);</line>
					</unmanaged>					
					<value>
						One of the <b>EnumEventType</b> values.
					</value>					
				</doc>
			</property>
			<property name="Category">
				<doc>
					<unmanaged>
						<line>public: EnumEventType getEventType( );</line>
						<line>public: virtual void setEventType(</line>
						<line>	EnumEventType anEventType</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An integer that represents the category to which the event belongs.
					</value>				
				</doc>
			</property>
			<property name="Severity">
				<doc>
					<unmanaged>
						<line>public: virtual EnumClassContext getClassContext( );</line>
						<line>public: virtual void setClassContext(</line>
						<line>	EnumClassContext aClassContext</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An integer that represents the event urgency.
					</value>					
				</doc>
			</property>
			<property name="SourcePath">
				<doc>
					<unmanaged>
						<line>public: virtual EnumClassContext getClassContext( );</line>
						<line>public: virtual void setClassContext(</line>
						<line>	EnumClassContext aClassContext</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents the reference path to the object which generated the event notification.
					</value>					
				</doc>
			</property>
			<property name="Message">
				<doc>
					<unmanaged>
						<line>public: virtual EnumClassContext getClassContext( );</line>
						<line>public: virtual void setClassContext(</line>
						<line>	EnumClassContext aClassContext</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents a textual description of the event.
					</value>					
				</doc>
			</property>
			<property name="OccurenceTime">
				<doc>
					<unmanaged>
						<line>public: DateTime getOcurrenceTime();</line>
						<line>public: void setOccurenceTime(</line>
						<line>	DateTime occurenceTime</line>
						<line>);</line>
					</unmanaged>
					<value>
						A <b>DataTime</b> object that represents the time the event occured.
					</value>
				</doc>
			</property>
			<property name="Attributes">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;Variant*&#62;&#38; getAttributes( );</line>
						<line>public: void setAttributes(</line>
						<line>	std::vector&#60;Variant*&#62; someAttributes</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A <b>DateTime</b> object that represents the time the event occured.
					</value>					
				</doc>
			</property>
			<property name="ActorId">
				<doc>
					<unmanaged>
						<line>public: virtual EnumClassContext getClassContext( );</line>
						<line>public: virtual void setClassContext(</line>
						<line>	EnumClassContext aClassContext</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents the client that initiated an action resulting in an event.
					</value>					
				</doc>
			</property>
		</class>
		<class name="AeCondition">
				<doc>
					<unmanaged>
						<line>class TBC_EXPORT AeCondition : public AeEvent</line>
					</unmanaged>	
				</doc>			
			<constructor name="AeCondition">
				<doc>
					<unmanaged>
						<line>public: AeCondition( );</line>
					</unmanaged>	
				</doc>
			</constructor>
			<field name="m_changeMask">
				<doc>
					<unmanaged>
						<line>protected: EnumConditionChange m_changeMask;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_newState">
				<doc>
					<unmanaged>
						<line>protected: EnumConditionState m_newState;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_ackRequired">
				<doc>
					<unmanaged>
						<line>protected: BOOL m_ackRequired;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_quality">
				<doc>
					<unmanaged>
						<line>protected: EnumQuality m_quality;</line>
					</unmanaged>					
				</doc>
			</field>
			<field name="m_conditionName">
				<doc>
					<unmanaged>
						<line>protected: tstring m_conditionName;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_subConditionName">
				<doc>
					<unmanaged>
						<line>protected: tstring m_subConditionName;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_activeTime">
				<doc>
					<unmanaged>
						<line>protected: DateTime m_activeTime;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_cookie">
				<doc>
					<unmanaged>
						<line>protected: unsigned long m_cookie;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_aeSession">
				<doc>
					<unmanaged>
						<line>protected: unsigned long m_cookie;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_aeSubscription">
				<doc>
					<unmanaged>
						<line>protected: unsigned long m_cookie;</line>
					</unmanaged>						
				</doc>
			</field>			
			<property name="AeSession">
				<doc>
					<unmanaged>
						<line>public: AeSession* getAeSession( );</line>
						<line>public: void setAeSession(</line>
						<line>	AeSession* anAeSession</line>
						<line>);</line>
					</unmanaged>					
					<value>
						The <b>AeSession</b> object  to whose eventarea the condition-related event belongs.
					</value>					
				</doc>
			</property>
			<property name="ChangeMask">
				<doc>
					<unmanaged>
						<line>public: EnumConditionChange getChangeMask( );</line>
						<line>public: void setChangeMask(</line>
						<line>	EnumConditionChange mask</line>
						<line>);</line>
					</unmanaged>					
					<value>
						One of the <b> EnumConditionChange </b> values.
					</value>				
				</doc>
			</property>
			<property name="State">
				<doc>
					<unmanaged>
						<line>public: EnumConditionState getState( );</line>
						<line>public: void setState(</line>
						<line>	EnumConditionState state</line>
						<line>);</line>
					</unmanaged>					
					<value>
						One of the <b>EnumConditionState</b> values.
					</value>					
				</doc>
			</property>
			<property name="AckRequired">
				<doc>
					<unmanaged>
						<line>public: BOOL getAckRequired( );</line>
						<line>public: void setAckRequired(</line>
						<line>	BOOL ackRequired</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A boolean that indicates whether an acknowledgement is or not required.
					</value>					
				</doc>
			</property>
			<property name="Quality">
				<doc>
					<unmanaged>
						<line>public: EnumQuality getQuality( );</line>
						<line>public: void setQuality(</line>
						<line>	EnumQuality quality</line>
						<line>);</line>
					</unmanaged>					
					<value>
						One of the <b>EnumQuality</b> values.
					</value>					
				</doc>
			</property>
			<property name="ConditionName">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getConditionName( );</line>
						<line>public: void setConditionName(</line>
						<line>	tstring conditionName</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents the name of the condition associated with the event.
					</value>					
				</doc>
			</property>
			<property name="SubConditionName">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getSubConditionName( );</line>
						<line>public: void setSubConditionName(</line>
						<line>	tstring subConditionName</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents the name of the currently active subcondition.
					</value>					
				</doc>
			</property>
			<property name="ActiveTime">
				<doc>
					<unmanaged>
						<line>public: DateTime getActiveTime( );</line>
						<line>public: void setActiveTime(</line>
						<line>	DateTime activeTime</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A <b>DateTime</b> object that represents the time when the condition became active.
					</value>					
				</doc>
			</property>
			<property name="Cookie">
				<doc>
					<unmanaged>
						<line>public: unsigned long getCookie( );</line>
						<line>public: virtual void setCookie(</line>
						<line>	unsigned long cookie</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An integer that represents a defined cookie associated with the event notification.
					</value>					
				</doc>
			</property>
			<method name="Acknowledge">
				<doc>
					<unmanaged>
						<line>public: virtual long acknowledge( </line>
						<line>	tstring ackId, </line>
						<line>	tstring ackComment, </line>						
						<line>	ExecutionOptions* executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>
						<note>
							<line>
								Before you use this method make sure that the session object to whom the condition-related event belongs is correctly set.								
							</line>							
						</note>						
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="UpdateConditionState">
				<doc>
					<unmanaged>
						<line>public: virtual long updateConditionState( </line>
						<line>	std::vector&#60;AeAttribute*&#62; attributes, </line>
						<line>	ExecutionOptions* executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>
						<note>
							<line>
								Before you use this method make sure that the session object to whom the condition-related event belongs is correctly set.								
							</line>							
						</note>						
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
		</class>
		<class name="AeConditionState">
				<doc>
					<unmanaged>
						<line>class TBC_EXPORT AeConditionState</line>
					</unmanaged>	
				</doc>			
			<constructor name="AeConditionState">
				<doc>
					<unmanaged>
						<line>public: AeConditionState();</line>
					</unmanaged>	
				</doc>
			</constructor>
			<field name="m_state">
				<doc>
					<unmanaged>
						<line>EnumConditionState m_state;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_actSubConditionName">
				<doc>
					<unmanaged>
						<line>tstring  m_actSubConditionName;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_actSubConditionDefinition">
				<doc>
					<unmanaged>
						<line>tstring  m_actSubConditionDefinition;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_actSubConditionSeverity">
				<doc>
					<unmanaged>
						<line>unsigned long m_actSubConditionSeverity;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_actSubConditionDescription">
				<doc>
					<unmanaged>
						<line>tstring m_actSubConditionDescription;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_conditionActiveTime">
				<doc>
					<unmanaged>
						<line>DateTime m_conditionActiveTime;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_conditionAckTime">
				<doc>
					<unmanaged>
						<line>DateTime m_conditionAckTime;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_subConditionActiveTime">
				<doc>
					<unmanaged>
						<line>DateTime m_subConditionActiveTime;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_conditionInactiveTime">
				<doc>
					<unmanaged>
						<line>DateTime m_conditionInactiveTime;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_quality">
				<doc>
					<unmanaged>
						<line>EnumQuality m_quality;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_ackId">
				<doc>
					<unmanaged>
						<line>tstring m_ackId;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_ackComment">
				<doc>
					<unmanaged>
						<line>tstring m_ackComment;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_pSubConditionDefinition">
				<doc>
					<unmanaged>
						<line>std::vector&#60;tstring&#62; m_pSubConditionDefinition;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_pSubConditionSeverity">
				<doc>
					<unmanaged>
						<line>std::vector&#60;unsigned long&#62; m_pSubConditionSeverity;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_pSubConditionDescription">
				<doc>
					<unmanaged>
						<line>std::vector&#60;tstring&#62; m_pSubConditionDescription ;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_pSubConditionName">
				<doc>
					<unmanaged>
						<line>std::vector&#60;tstring&#62; m_pSubConditionName ;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_pEventAttrs">
				<doc>
					<unmanaged>
						<line>std::vector&#60;Variant*&#62; m_pEventAttrs ;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_pAttrErrors">
				<doc>
					<unmanaged>
						<line>std::vector&#60;long&#62; m_pAttrErrors ; </line>
					</unmanaged>						
				</doc>
			</field>
			<property name="State">
				<doc>
					<unmanaged>
						<line>public: EnumConditionState getState( );</line>
						<line>public: void setState(</line>
						<line>	EnumConditionState aState</line>
						<line>);</line>
					</unmanaged>					
					<value>
						One of the <b>EnumConditionState</b> values.
					</value>					
				</doc>
			</property>
			<property name="ActiveSubConditionName">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getActiveSubConditionName();</line>
						<line>public: void setActiveSubConditionName(</line>
						<line>	tstring subConditionName</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents the name of the currently active sub-condition.
					</value>					
				</doc>
			</property>
			<property name="ActiveSubConditionDefinition">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getActiveSubConditionDefinition();</line>
						<line>public: void setActiveSubConditionDefinition(</line>
						<line>	tstring subConditionDefinition</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents an expression which defines the sub-state represented by the sub-condition which is currently active.
					</value>					
				</doc>
			</property>
			<property name="ActiveSubConditionSeverity">
				<doc>
					<unmanaged>
						<line>public: unsigned long getActiveSubConditionSeverity( );</line>
						<line>public: void setActiveSubConditionSeverity(</line>
						<line>	unsigned long subConditionSeverity</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An integer that represents the severity of an event notification generated on behalf of the currently active sub-condition.
					</value>	
					<remarks>
						Different sub-conditions of the same condition may have different severity levels.
					</remarks>
				</doc>
			</property>
			<property name="ActiveSubConditionDescription">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getActiveSubConditionDescription( );</line>
						<line>public: void setActiveSubConditionDescription(</line>
						<line>	tstring subConditionDescription</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents the text to be included in any event notification generated on behalf of the currently active sub-condition.
					</value>					
				</doc>
			</property>
			<property name="ConditionActiveTime">
				<doc>
					<unmanaged>
						<line>public: DateTime getConditionActiveTime();</line>
						<line>public: void setConditionActiveTime(</line>
						<line>	DateTime conditionActiveTime</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A <b>DateTime</b> object that represents the time that the condition become active.
					</value>					
				</doc>
			</property>
			<property name="ConditionAckTime">
				<doc>
					<unmanaged>
						<line>public: DateTime getConditionAckTime();</line>
						<line>public: void setConditionAckTime(</line>
						<line>	DateTime ackTime</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A <b>DateTime</b> object that represents the time of the most recent acknowledgement (of any sub-condition).
					</value>					
				</doc>
			</property>
			<property name="SubConditionActiveTime">
				<doc>
					<unmanaged>
						<line>public: DateTime getSubConditionActiveTime( );</line>
						<line>public: void setSubConditionActiveTime(</line>
						<line>	DateTime activeTime</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A <b>DateTime</b> object that represents the time of the most recent transition into the currently active sub-condition.
					</value>					
				</doc>
			</property>
			<property name="ConditionInactiveTime">
				<doc>
					<unmanaged>
						<line>public: DateTime getConditionInactiveTime();</line>
						<line>public: void setConditionInactiveTime(</line>
						<line>	DateTime inactiveTime</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A <b>DateTime</b> object that represents the time of the most recent transition out of the condition.
					</value>					
				</doc>
			</property>
			<property name="Quality">
				<doc>
					<unmanaged>
						<line>public: EnumQuality getQuality();</line>
						<line>public: void setQuality(</line>
						<line>	EnumQuality quality</line>
						<line>);</line>
					</unmanaged>					
					<value>
						One of the <b>EnumQuality</b> values.
					</value>					
				</doc>
			</property>
			<property name="AcknowledgerId">
				<doc>
					<unmanaged>
						<line>public: 	tstring&#38; getAcknowledgerId( );</line>
						<line>public: void setAcknowledgerId(</line>
						<line>	tstring acknowledgerId</line>
						<line>);</line>
					</unmanaged>					
					<value>
						a string that represents an identifier for the client who last acknowledged the condition.
					</value>					
				</doc>
			</property>
			<property name="AcknowledgerComment">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getAcknowledgerComment();</line>
						<line>public: void setAcknowledgerComment(</line>
						<line>	tstring acknowledgerComment</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents a comment string passed in by the client who last acknowledged the condition.
					</value>					
				</doc>
			</property>
			<property name="SubConditionsDefinitions">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;tstring&#62;&#38; getSubConditionsDefinitions();</line>
						<line>public: void setSubConditionsDefinitions(</line>
						<line>	std::vector&#60;tstring&#62; subConditionsDefinition</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An array of strings that represents the list with the definitions of all the sub-conditions of the current condition.
					</value>					
				</doc>
			</property>
			<property name="SubConditionsSeverities">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;unsigned long&#62;&#38; getSubConditionsSeverities();</line>
						<line>public: void setSubConditionsSeverities(</line>
						<line>	std::vector&#60;unsigned long&#62; subConditionsSeverities</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An array of integers that represents a list with the severity of all the sub-conditions of the current condition.
					</value>					
				</doc>
			</property>
			<property name="SubConditionsDescriptions">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;tstring&#62;&#38; getSubConditionsDescriptions( );</line>
						<line>public: void setSubConditionsDescriptions(</line>
						<line>	std::vector&#60;tstring&#62; subConditionsDescription</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A list with strings that represents a list with the description of all the sub-conditions of the current condition.
					</value>					
				</doc>
			</property>
			<property name="SubConditionsNames">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;tstring&#62;&#38; getSubConditionsNames( );</line>
						<line>public: void setSubConditionsNames(</line>
						<line>	std::vector&#60;tstring&#62; subConditionsName</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An array of strings that represents a list with all the names associated with the sub-conditions of the current condition.
					</value>					
				</doc>
			</property>
			<property name="EventAttributes">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;Variant*&#62;&#38; getEventAttributes( );</line>
						<line>public: void setEventAttributes(</line>
						<line>	std::vector&#60;Variant*&#62; eventAttributes</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An array of <b>Variant</b> objects that represents a list of vendor-specific attributes to be sent with the event notification.
					</value>					
				</doc>
			</property>
			<property name="AttributesErrors">
				<doc>
					<unmanaged>
						<line>public: std::vector&#60;long&#62;&#38; getAttributesErrors();</line>
						<line>public: void setAttributesErrors(</line>
						<line>	std::vector&#60;long&#62; eventErrors</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An array of integers that represent a list with the errors occured when transmitting the attributes with the event notification. 
					</value>					
				</doc>
			</property>
		</class>
		<class name="AeCategory">
				<doc>
					<unmanaged>
						<line>class TBC_EXPORT AeCategory</line>
					</unmanaged>	
				</doc>			
			<constructor name="AeCategory">
				<doc>
					<unmanaged>
						<line>public: AeCategory( );</line>
					</unmanaged>	
				</doc>
			</constructor>
			<field name="m_eventType">
				<doc>
					<unmanaged>
						<line>EnumEventType m_eventType;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_Id">
				<doc>
					<unmanaged>
						<line>unsigned long m_id;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_description">
				<doc>
					<unmanaged>
						<line>tstring m_description;</line>
					</unmanaged>						
				</doc>
			</field>
			<field name="m_aeSession">
				<doc>
					<unmanaged>
						<line>AeSession* m_aeSession;</line>
					</unmanaged>						
				</doc>
			</field>
			<method name="GetHashCode">
				<doc>
					<unmanaged>
						<line>public: unsigned long getCategoryCode( );</line>
					</unmanaged>				
					<remarks>
						The category code is internally generated.
					</remarks>
				</doc>
			</method>	
			<property name="EventType">
				<doc>
					<unmanaged>
						<line>public: EnumEventType getEventType( );</line>
						<line>public: void setEventType(</line>
						<line>	EnumEventType anEventType</line>
						<line>);</line>
					</unmanaged>					
					<value>
						One of the <b>EnumEventType</b> values.
					</value>					
				</doc>
			</property>
			<property name="Id">
				<doc>
					<unmanaged>
						<line>public: unsigned long getId( );</line>
						<line>public: void setId(</line>
						<line>	unsigned long id</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An integer that represents an identifier for the category.
					</value>					
				</doc>
			</property>
			<property name="Description">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getDescription( );</line>
						<line>public:  void setDescription(</line>
						<line>	tstring description</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents a text that describes the category.
					</value>					
				</doc>
			</property>
			<property name="Session">
				<doc>
					<unmanaged>
						<line>public: AeSession* getSession( );</line>
						<line>public: void setSession(</line>
						<line>	AeSession* anAeSession</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An <b>AeSession</b> object that represents the session that supports the events in the category.
					</value>					
				</doc>
			</property>
			<event name="QueryAeAttributtesCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleQueryAeAttributesCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	unsigned long categoryId,</line>
						<line>	std&#58;&#58;vector&#60;AeAttribute&#42;&#62;&#38; attributes,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="QueryAeConditionNamesCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleQueryAeConditionNamesCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	unsigned long categoryId,</line>
						<line>	std&#58;&#58;vector&#60;tstring&#62;&#38; conditionNames,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<event name="QueryAeSubConditionNamesCompleted">
				<doc>
					<unmanaged>
						<line>virtual void handleQueryAeSubConditionNamesCompleted(</line>
						<line>	unsigned long executionContext,</line>
						<line>	tstring&#38; conditionName,</line>
						<line>	std&#58;&#58;vector&#60;tstring&#62;&#38; subConditionNames,</line>
						<line>	long result</line>
						<line>);</line>
					</unmanaged>												
				</doc>
			</event>
			<method name="QueryAeAttributes">
				<doc>
					<unmanaged>
						<line>public: virtual long queryAeAttributes( </line>
						<line>std::vector&#60;AeAttribute*&#62;&#38; attributes,</line>
						<line>	ExecutionOptions&#42; executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>
						<para><b>Unmanaged C++</b></para><para>
						In the toolkit, memory is allocated for the <b>attributes</b> array and must be deallocated after finishing the query attributes operation. In case the operation is <b>synchronous</b> this must be undertaken by the person that uses the toolkit. In case the operation is <b>asynchronous</b> this memory is deallocated in the toolkit and nobody has to care about deallocating it.</para>
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="QueryAeConditionNames">
				<doc>
					<unmanaged>
						<line>public: 	virtual long queryAeConditionNames( </line>
						<line>	std::vector&#60;tstring&#62;&#38; conditionNames,</line>
						<line>	ExecutionOptions&#42; executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>						
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
			<method name="QueryAeSubConditionNames">
				<doc>
					<unmanaged>
						<line>public:virtual long queryAeSubConditionsNames( </line>
						<line>	tstring conditionName,</line>
						<line>	std::vector&#60;tstring&#62;&#38; subConditionNames,</line>
						<line>	ExecutionOptions&#42; executionOptions </line>
						<line>); </line>	
					</unmanaged>
					<remarks>
						<line>The returned value should be checked with <b>SUCCEEDED</b> or <b>FAILED</b>.</line>						
						<para><b>C#, Visual Basic, C++, Unmanaged C++</b></para>
						<para>
							For more information on how to use the ExecutionOptions object
							please refer to the <link href="bc435923-131a-4d36-afa5-aa5ff28e3fab">
							Synchronous and Asynchronous</link> chapter in the Client section of the Programmer's Guide topic.
						</para>
					</remarks>
				</doc>
			</method>
		</class>
		<class name="AeAttribute">
				<doc>
					<unmanaged>
						<line>class TBC_EXPORT AeAttribute</line>
					</unmanaged>	
				</doc>
			<constructor name="AeAttribute1">
				<doc>
					<unmanaged>
						<line>public: AeAttribute( );</line>
					</unmanaged>
				</doc>
			</constructor>
			<constructor name="AeAttribute2">
				<doc>
					<unmanaged>
						<line>public: AeAttribute(</line>
						<line>unsigned long id,</line>
						<line>tstring description,</line>
						<line>unsigned short type);</line>
					</unmanaged>
				</doc>
			</constructor>
			
			<field name="m_Id">
					<doc>
						<unmanaged>
							<line>protected: unsigned long m_id;</line>						
						</unmanaged>
					</doc>
			</field>
			<field name="m_description">
					<doc>
						<unmanaged>
							<line>protected: tstring m_description;</line>						
						</unmanaged>
					</doc>
			</field>
			<field name="m_dataType">
					<doc>
						<unmanaged>
							<line>protected: VARTYPE m_dataType;</line>						
						</unmanaged>
					</doc>
			</field>
			<property name="Id">
				<doc>
					<unmanaged>
						<line>public: unsigned long getId( );</line>
						<line>public: void setId(</line>
						<line>	unsigned long id</line>
						<line>);</line>
					</unmanaged>					
					<value>
						An integer that represents a numeric identifier for the current attribute.
					</value>					
				</doc>
			</property>
			<property name="Description">
				<doc>
					<unmanaged>
						<line>public: tstring&#38; getDescription( );</line>
						<line>public:  void setDescription(</line>
						<line>	tstring description</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A string that represents a text that describes the current attribute.
					</value>					
				</doc>
			</property>
			<property name="DataType">
				<doc>
					<unmanaged>
						<line>public: VARTYPE getDataType( );</line>
						<line>public: void setDataType</line>
						<line>	VARTYPE dataType</line>
						<line>);</line>
					</unmanaged>					
					<value>
						A data type for the current attribute. 
					</value>					
				</doc>
			</property>
		</class>
		<delegate name="QueryAeAttributesEventHandler">
				<doc>
					<unmanaged>
					</unmanaged>	
				</doc>
		</delegate>
		<delegate name="BrowseServersEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="StateChangeEventHandler">
			<doc>
				<unmanaged>				
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="GetAttributesFromServerEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="SetAttributesToServerEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="PerformStateTransitionEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="ShutdownEventHandler">
			<doc>
				<unmanaged>						
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="DataChangedEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>
			</doc>
		</delegate>
		<delegate name="DataChangedExEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>
			</doc>
		</delegate>
		<delegate name="ValidateDaItemsEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="GetDaItemAttributesFromServerEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="SetDaItemAttributesToServerEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="SubscriptionReadEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="SubscriptionWriteEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="ValueChangedEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="ControlDataChangedEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="AeEventsReceivedEventHandler">
			<doc>
				<unmanaged>			
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="RefreshAeConditionsEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="CancelRefreshAeConditionsEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="AeConditionsChangedEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="BrowseAeServerEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="QueryAeCategoriesEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="QueryAvailableAeFiltersEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="EnableAeConditionsByAreaEventHandler">
			<doc>
				<unmanaged>			
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="EnableAeConditionsBySourceEventHandler">
			<doc>
				<unmanaged>			
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="AcknowledgeAeConditionsEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="QueryAeSourceConditonsEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="GetAeConditionStateEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="QueryAeConditionNamesEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="QueryAeSubConditionNamesEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="SessionReadEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="SessionWriteEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="GetStatusEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="BrowseDaServerEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="GetDaPropertiesEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="GetErrorStringEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="LogonEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>
		<delegate name="LogoffEventHandler">
			<doc>
				<unmanaged>
				</unmanaged>	
			</doc>
		</delegate>		
	</namespace>
</lib>
